{-# LANGUAGE GADTs               #-}
{-# LANGUAGE DeriveGeneric       #-}
{-# LANGUAGE FlexibleInstances   #-}
{-# LANGUAGE ScopedTypeVariables #-}

module Ouroboros.Network.Protocol.VersionNegotiation.Test where

import           Control.Monad.ST (runST)
import           Data.Bool (bool)
import           Data.ByteString.Lazy (ByteString)
import qualified Data.Text as T
import           Data.Typeable (Typeable, cast)
import           Data.List (nub)
import           Data.Maybe (isJust)
import qualified Data.Map as Map
import           GHC.Generics

import           Control.Monad.IOSim (runSimOrThrow)
import           Control.Monad.Class.MonadAsync (MonadAsync)
import           Control.Monad.Class.MonadST (MonadST)
import           Control.Monad.Class.MonadThrow (MonadCatch)
import           Control.Tracer (nullTracer)

import           Network.TypedProtocol.Codec
import           Network.TypedProtocol.Channel
import           Network.TypedProtocol.Driver
import           Network.TypedProtocol.Proofs
import           Ouroboros.Network.Channel

import           Test.Ouroboros.Network.Testing.Utils (splits2, splits3)

import           Ouroboros.Network.Protocol.VersionNegotiation.Type
import           Ouroboros.Network.Protocol.VersionNegotiation.Codec
import           Ouroboros.Network.Protocol.VersionNegotiation.Version

import qualified Codec.CBOR.Encoding as CBOR
import qualified Codec.CBOR.Decoding as CBOR
import qualified Codec.CBOR.Term as CBOR
import           Codec.Serialise (Serialise)
import qualified Codec.Serialise     as CBOR

import           Test.QuickCheck
import           Test.Tasty (TestTree, testGroup)
import           Test.Tasty.QuickCheck (testProperty)

tests :: TestTree
tests =
  testGroup "Ouroboros.Network.Protocol.VersionNegotiation"
  [ testProperty "connect"             prop_connect
  , testProperty "channel ST"          prop_channel_ST
  , testProperty "channel IO"          prop_channel_IO
  , testProperty "pipe IO"             prop_pipe_IO
  , testProperty "codec RefuseReason"  prop_codec_RefuseReason
  , testProperty "codec"               prop_codec_VersionNegotiation
  , testProperty "codec 2-splits"      prop_codec_splits2_VersionNegotiation
  , testProperty "codec 3-splits"    $ withMaxSuccess 30
                                       prop_codec_splits3_VersionNegotiation
  , testGroup "Generators"
    [ testProperty "ArbitraryVersions" $
        checkCoverage prop_arbitrary_ArbitraryVersions
    , testProperty "arbitrary ArbitraryValidVersions"
        prop_arbitrary_ArbitraryValidVersions
    , testProperty "shrink ArbitraryValidVersions"
        prop_shrink_ArbitraryValidVersions
    ]
  ]

--
-- Test Versions
--
-- Notes: Associated data are choosen in such a way that a decoder will fail
-- interpreting one of them as the other.  This is done on purpose for testing
-- missencoded data (protocol version & associated version data mismatch)
--

-- |
-- Testing version number
--
data VersionNumber
  = Version_0
  | Version_1
  | Version_2
  deriving (Eq, Ord, Enum, Bounded, Show)

instance Arbitrary VersionNumber where
  arbitrary = elements [minBound .. maxBound]

instance Serialise VersionNumber where
  encode Version_0 = CBOR.encodeWord 0
  encode Version_1 = CBOR.encodeWord 1
  encode Version_2 = CBOR.encodeWord 2

  decode = do
    x <- CBOR.decodeWord
    case x of
      0 -> return Version_0
      1 -> return Version_1
      2 -> return Version_2
      _ -> fail "decode VersionNumber: wrong tag"

-- |
-- Data Associated with @'Version_0'@
--
data Data_0 = C0 | C1 | C2
  deriving (Eq, Show, Typeable, Generic)

instance SerialiseTerm Data_0 where
  -- We are using @CBOR.TInt@ instead of @CBOR.TInteger@, since for small
  -- integers generated by QuickCheck they will be encoded as @TkInt@ and then
  -- are decodec back to @CBOR.TInt@ rather than @COBR.TInteger@.  The same for
  -- other @SerialiseTerm@ instances in this module.
  encodeTerm C0 = CBOR.TInt 0
  encodeTerm C1 = CBOR.TInt 1
  encodeTerm C2 = CBOR.TInt 2

  decodeTerm (CBOR.TInt 0) = Right C0
  decodeTerm (CBOR.TInt 1) = Right C1
  decodeTerm (CBOR.TInt 2) = Right C2
  decodeTerm n             = Left $ T.pack $ "decodeTerm Data_0: unrecognised tag: " ++ show n

instance Arbitrary Data_0 where
  arbitrary = elements [C0, C1, C2]

instance CoArbitrary Data_0 where

-- |
-- Data associated with @'Version_1'@
--
data Data_1 = Data_1 Bool
  deriving (Eq, Show, Typeable, Generic)

instance SerialiseTerm Data_1 where
  encodeTerm (Data_1 b) = CBOR.TBool b

  decodeTerm (CBOR.TBool b) = Right (Data_1 b)
  decodeTerm _              = Left $ T.pack "decodeTerm Data_1: wrong encoding"

instance Arbitrary Data_1 where
  arbitrary = Data_1 <$> arbitrary
  shrink = genericShrink

instance CoArbitrary Data_1

-- |
-- Data associated with @'Version_2'@
--
data Data_2 = Data_2 Word Word
  deriving (Eq, Show, Typeable, Generic)

instance SerialiseTerm Data_2 where
  encodeTerm (Data_2 n m) = CBOR.TList [CBOR.TInt (fromIntegral n), CBOR.TInt (fromIntegral m)]
  decodeTerm (CBOR.TList (CBOR.TInt n : CBOR.TInt m : _)) = Right (Data_2 (fromIntegral n) (fromIntegral m))
  decodeTerm _ = Left $ T.pack "decodeTerm Data_2: wrong encoding"

instance Arbitrary Data_2 where
  arbitrary = Data_2 <$> arbitrary <*> arbitrary
  shrink = genericShrink

instance CoArbitrary Data_2 where

data DictVersion vData where
     DictVersion :: ( Typeable vData
                    , Eq vData
                    , SerialiseTerm vData
                    , Show vData
                    )
                 => DictVersion vData

--
-- ProtocolVersion generators
--

-- |
-- Generate a valid @'ProtocolVersion' 'VersionNumber' r@
--
genValidVersion
  :: VersionNumber
  -> Gen (Sigma (Version DictVersion Bool))
genValidVersion Version_0 = do
  (d0 :: Data_0) <- arbitrary
  return $ Sigma d0 (Version (Application (==)) DictVersion)
genValidVersion Version_1 = do
  (d1 :: Data_1) <- arbitrary
  return $ Sigma d1 (Version (Application (==)) DictVersion)
genValidVersion Version_2 = do
  (d2 :: Data_2) <- arbitrary
  return $ Sigma d2 (Version (Application (==)) DictVersion)


-- |
-- Generate an invalid @'ProtocolVersion' 'VersionNumber' r@.
--
genInvalidVersion
  :: VersionNumber
  -> Gen (Sigma (Version DictVersion Bool))
genInvalidVersion Version_0 = arbitrary >>= \b ->
  if b
    then do
      (d1 :: Data_1) <- arbitrary
      return $ Sigma d1 (Version (Application (==)) DictVersion)
    else do
      (d2 :: Data_2) <- arbitrary
      return $ Sigma d2 (Version (Application (==)) DictVersion)
genInvalidVersion Version_1 = arbitrary >>= \b ->
  if b
    then do
      (d0 :: Data_0) <- arbitrary
      return $ Sigma d0 (Version (Application (==)) DictVersion)
    else do
      (d2 :: Data_2) <- arbitrary
      return $ Sigma d2 (Version (Application (==)) DictVersion)
genInvalidVersion Version_2 = arbitrary >>= \b ->
  if b
    then do
      (d0 :: Data_0) <- arbitrary
      return $ Sigma d0 (Version (Application (==)) DictVersion)
    else do
      (d1 :: Data_1) <- arbitrary
      return $ Sigma d1 (Version (Application (==)) DictVersion)

-- |
-- Generate valid @Versions@.
--
genValidVersions :: Gen (Versions VersionNumber DictVersion Bool)
genValidVersions = do
  vns <- nub <$> resize 3 (listOf1 (arbitrary :: Gen VersionNumber))
  vs <- traverse genValidVersion vns
  return $ Versions $ Map.fromList $ zip vns vs

-- |
-- Generate possible invalid @Versions@.
--
genVersions :: Gen (Versions VersionNumber DictVersion Bool)
genVersions = do
  vns <- nub <$> resize 3 (listOf1 (arbitrary :: Gen VersionNumber))
  vs <- traverse (\v -> oneof [genValidVersion v, genInvalidVersion v]) vns
  return $ Versions $ Map.fromList $ zip vns vs

newtype ArbitraryValidVersions = ArbitraryValidVersions {
      runArbitraryValidVersions :: Versions VersionNumber DictVersion Bool
    }

instance Show ArbitraryValidVersions where
    show (ArbitraryValidVersions (Versions vs)) = show $ map (\(vn, Sigma vData (Version _ DictVersion)) -> (vn, show vData)) $ Map.toList vs

instance Arbitrary ArbitraryValidVersions where
    arbitrary = ArbitraryValidVersions <$> genValidVersions
    shrink (ArbitraryValidVersions (Versions vs)) =
      [ ArbitraryValidVersions (Versions $ Map.fromList vs')
      | vs' <- shrinkList (const []) (Map.toList vs)
      ]

prop_arbitrary_ArbitraryValidVersions
  :: ArbitraryValidVersions
  -> Bool
prop_arbitrary_ArbitraryValidVersions (ArbitraryValidVersions vs) = Map.foldlWithKey' (\r vn s -> r && validVersion vn s) True (getVersions vs)

prop_shrink_ArbitraryValidVersions
  :: ArbitraryValidVersions
  -> Bool
prop_shrink_ArbitraryValidVersions a = all id
  [ Map.foldlWithKey' (\r vn s -> r && validVersion vn s) True (getVersions vs')
  | ArbitraryValidVersions vs' <- shrink a
  ]

-- |
-- Generators for pairs of arbitrary list of versions.
--
data ArbitraryVersions =
  ArbitraryVersions
    (Versions VersionNumber DictVersion Bool)
    (Versions VersionNumber DictVersion Bool)

instance Show ArbitraryVersions where
    show (ArbitraryVersions (Versions vs) (Versions vs')) = "ArbitraryVersions " ++ fn vs ++ " " ++ fn vs'
         where
           fn x = show $ map (\(vn, Sigma vData (Version _ DictVersion)) -> (vn, show vData)) $ Map.toList x

instance Arbitrary ArbitraryVersions where
    arbitrary = frequency
      [ (1, (\v -> ArbitraryVersions v v) <$> genVersions)
      , (2, ArbitraryVersions <$> genVersions <*> genVersions)
      ]
    shrink (ArbitraryVersions (Versions vs) (Versions vs')) = 
      [ ArbitraryVersions (Versions $ Map.fromList vs'') (Versions vs')
      | vs'' <- shrinkList (const []) (Map.toList vs)
      ] ++
      [ ArbitraryVersions (Versions vs) (Versions $ Map.fromList vs'')
      | vs'' <- shrinkList (const []) (Map.toList vs')
      ]


-- |
-- Check if a @'ProtocolVersion' 'VersionNumber' r@ is valid.
--
validVersion :: VersionNumber -> Sigma (Version DictVersion Bool) -> Bool
validVersion Version_0 (Sigma d (Version _ DictVersion)) = isJust (cast d :: Maybe Data_0)
validVersion Version_1 (Sigma d (Version _ DictVersion)) = isJust (cast d :: Maybe Data_1)
validVersion Version_2 (Sigma d (Version _ DictVersion)) = isJust (cast d :: Maybe Data_2)


prop_arbitrary_ArbitraryVersions :: ArbitraryVersions -> Property
prop_arbitrary_ArbitraryVersions (ArbitraryVersions (Versions vs) (Versions vs')) =
    -- in 80% of cases the intersection is non-empty
    cover 80 intersect "non-empty intersection" $

    -- in 10% of cases the intersection is empty
    cover 10 (not intersect) "empty intersection" $

    -- in 25% of cases the common max version is valid
    cover 25 (case Map.lookupMax intersection of
               Nothing -> False
               Just (vn, s)  -> validVersion vn s)
               "valid common max version" $

    -- in 40% of cases all the versions in @vs'@ are either not in @vs@ or are
    -- not valid
    cover 40
      (Map.foldlWithKey' (\r vn s -> r && (not (vn `elem` knownVersionNumbers) || not (validVersion vn s))) True vs)
      "all versions are either unknown or not valid" $

    property True
  where
    intersection = vs `Map.intersection` vs' 
    intersect    = not (Map.null intersection)

    knownVersionNumbers = Map.keys vs'

-- | Run a version negotiation, but without going via a channel.
--
prop_connect :: ArbitraryVersions -> Property
prop_connect (ArbitraryVersions clientVersions serverVersions) =
  let (serverRes, clientRes) = pureVersionNegotiation
        (\DictVersion -> Dict)
        (\DictVersion -> (==))
        serverVersions
        clientVersions
  in case runSimOrThrow
           (connect
              (versionNegotiationClientPeer
                (\DictVersion -> encodeTerm)
                (\DictVersion -> decodeTerm)
                clientVersions)
              (versionNegotiationServerPeer
                (\DictVersion -> encodeTerm)
                (\DictVersion -> decodeTerm)
                (\DictVersion vData vData' -> bool (Refuse $ T.pack "refused") Accept $ vData == vData')
                serverVersions)) of
      (clientRes', serverRes', TerminalStates TokDone TokDone) ->
           maybe False id clientRes === either (const False) id clientRes'
        .&&.
           maybe False id serverRes === either (const False) id serverRes'
--
-- Properties using a channel
--

-- | Run a simple block-fetch client and server using connected channels.
--
prop_channel :: ( MonadAsync m
                , MonadCatch m
                , MonadST m
                )
             => m (Channel m ByteString, Channel m ByteString)
             -> Versions VersionNumber DictVersion Bool
             -> Versions VersionNumber DictVersion Bool
             -> m Property
prop_channel createChannels clientVersions serverVersions =
  let (serverRes, clientRes) = pureVersionNegotiation
        (\DictVersion -> Dict)
        (\DictVersion -> (==))
        serverVersions
        clientVersions
  in do
    (clientRes', serverRes') <-
      runConnectedPeers
        createChannels nullTracer codecVersionNegotiation
        (versionNegotiationClientPeer
          (\DictVersion -> encodeTerm)
          (\DictVersion -> decodeTerm)
          clientVersions)
        (versionNegotiationServerPeer
          (\DictVersion -> encodeTerm)
          (\DictVersion -> decodeTerm)
          (\DictVersion vData vData' -> bool (Refuse $ T.pack "") Accept $ vData == vData')
          serverVersions)
    return $ 
           maybe False id clientRes === either (const False) id clientRes'
      .&&.
           maybe False id serverRes === either (const False) id serverRes'


-- | Run 'prop_channel' in the simulation monad.
--
prop_channel_ST :: ArbitraryVersions -> Property
prop_channel_ST (ArbitraryVersions clientVersions serverVersions) =
    runSimOrThrow (prop_channel createConnectedChannels clientVersions serverVersions)


-- | Run 'prop_channel' in the IO monad.
--
prop_channel_IO :: ArbitraryVersions -> Property
prop_channel_IO (ArbitraryVersions clientVersions serverVersions) =
    ioProperty (prop_channel createConnectedChannels clientVersions serverVersions)


-- | Run 'prop_channel' in the IO monad using local pipes.
--
prop_pipe_IO :: ArbitraryVersions -> Property
prop_pipe_IO (ArbitraryVersions clientVersions serverVersions) =
    ioProperty (prop_channel createPipeConnectedChannels clientVersions serverVersions)

--
-- Codec tests
--

instance Eq (AnyMessage (VersionNegotiationProtocol VersionNumber CBOR.Term)) where
  AnyMessage (MsgProposeVersions vs)          == AnyMessage (MsgProposeVersions vs')  = vs == vs'
  AnyMessage (MsgAcceptVersion vNumber vParams) == AnyMessage (MsgAcceptVersion vNumber' vParams')
                                                                                      = vNumber == vNumber' && vParams == vParams'
  AnyMessage (MsgRefuse vReason)              == AnyMessage (MsgRefuse vReason')      = vReason == vReason'
  _                                           == _                                    = False

instance Show (AnyMessageAndAgency (VersionNegotiationProtocol VersionNumber CBOR.Term)) where
  show (AnyMessageAndAgency _ msg) = show msg

instance Arbitrary (AnyMessageAndAgency (VersionNegotiationProtocol VersionNumber CBOR.Term)) where
  arbitrary = oneof
    [ AnyMessageAndAgency (ClientAgency TokPropose) . MsgProposeVersions . fmap (\(Sigma vData (Version _ DictVersion)) -> encodeTerm vData) . getVersions <$> genVersions
    , AnyMessageAndAgency (ServerAgency TokConfirm) . uncurry MsgAcceptVersion <$> genValidVersion'
    , AnyMessageAndAgency (ServerAgency TokConfirm) . MsgRefuse . runArbitraryRefuseReason <$> arbitrary
    ]
    where
      genValidVersion' :: Gen (VersionNumber, CBOR.Term)
      genValidVersion' = do
        vn <- arbitrary
        Sigma vData (Version _ DictVersion) <- genValidVersion vn
        pure (vn, encodeTerm vData)


newtype ArbitraryRefuseReason = ArbitraryRefuseReason {
    runArbitraryRefuseReason :: RefuseReason VersionNumber
  }
  deriving (Eq, Show)


instance Arbitrary ArbitraryRefuseReason where
    arbitrary = ArbitraryRefuseReason <$> oneof
      [ VersionMismatch <$> arbitrary
      , VersionNegotiationDecodeError <$> arbitrary <*> arbitraryText
      , Refused <$> arbitrary <*> arbitraryText
      ]
      where
        arbitraryText = T.pack <$> arbitrary


prop_codec_RefuseReason
  :: ArbitraryRefuseReason
  -> Bool
prop_codec_RefuseReason (ArbitraryRefuseReason vReason) = 
  CBOR.deserialise (CBOR.serialise vReason) == vReason

prop_codec_VersionNegotiation
  :: AnyMessageAndAgency (VersionNegotiationProtocol VersionNumber CBOR.Term)
  -> Bool
prop_codec_VersionNegotiation msg =
  runST (prop_codecM codecVersionNegotiation msg)

prop_codec_splits2_VersionNegotiation
  :: AnyMessageAndAgency (VersionNegotiationProtocol VersionNumber CBOR.Term)
  -> Bool
prop_codec_splits2_VersionNegotiation msg =
  runST (prop_codec_splitsM splits2 codecVersionNegotiation msg)

prop_codec_splits3_VersionNegotiation
  :: AnyMessageAndAgency (VersionNegotiationProtocol VersionNumber CBOR.Term)
  -> Bool
prop_codec_splits3_VersionNegotiation msg =
  runST (prop_codec_splitsM splits3 codecVersionNegotiation msg)
