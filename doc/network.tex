\documentclass{report}
\usepackage[margin=2.5cm]{geometry}
\usepackage{amsmath, amssymb, stmaryrd, latexsym, amsthm, mathtools}
\usepackage{mathpazo, times}
\usepackage{float}
\usepackage{listings}
\usepackage{url}
\usepackage{natbib}
% \usepackage{parskip} % very ugly with lemmas, invariants, etc without intervening text
\usepackage[disable]{todonotes}
\usepackage{slashed}
\usepackage{tikz}
\usetikzlibrary{automata, positioning, arrows}
\tikzset{
    state/.style={
           rectangle,
           rounded corners,
           draw=black, very thick,
           minimum height=2em,
           inner sep=2pt,
           text centered,
           },
}

\usepackage{forest}
\usepackage{IEEEtrantools}
\usepackage{microtype}
\usepackage{graphicx,color}

\usepackage{hyperref}
\hypersetup{
  colorlinks=false,
  linkcolor={blue},
  citecolor={blue},
  urlcolor={blue},
  linkbordercolor={white},
  citebordercolor={white},
  urlbordercolor={white}
}
\usepackage[capitalise,noabbrev,nameinlink]{cleveref}

% https://tex.stackexchange.com/questions/132823/ieeetrantools-clash-with-cleveref
\makeatletter
\let\if@IEEEissubequation\iffalse
\makeatother

\usetikzlibrary{arrows}

\newcommand{\coot}[1]{\textcolor{violet}{\emph{#1}}}
\newcommand{\njd}[1]{\textcolor{purple}{\emph{#1}}}
\newcommand{\avieth}[1]{\textcolor{blue}{\emph{#1}}}
\newcommand{\dcoutts}[1]{\textcolor{orange}{\emph{#1}}}
\addtolength{\marginparwidth}{-0.1\marginparwidth}

\newcommand{\var}[1]{\mathit{#1}}
\newcommand{\type}[1]{\mathsf{#1}}
\newcommand{\powerset}[1]{\mathbb{P}(#1)}
\newcommand{\order}[1]{\mathcal{O}\left(#1\right)}
\newcommand{\restrictdom}{\lhd}
\newcommand{\subtractdom}{\mathbin{\slashed{\restrictdom}}}
\newcommand{\restrictrange}{\rhd}

\DeclareMathOperator{\dom}{dom}
\DeclareMathOperator{\range}{range}
\DeclareMathOperator*{\argmin}{arg\,min} % thin space, limits underneath in displays
\DeclareMathOperator*{\minimum}{min}
\DeclareMathOperator*{\maximum}{max}

% Number within sections, and don't have separate counters for separate environments
\theoremstyle{definition}{
  \newtheorem{lemma}{Lemma}[section] % Number within sections
  \newtheorem{definition}[lemma]{Definition}
}
\theoremstyle{theorem}{
  \newtheorem{invariant}[lemma]{Invariant}
  \newtheorem{proofobligation}[lemma]{Proof Obligation}
}

\Crefname{invariant}{Invariant}{Invariants}

\numberwithin{equation}{lemma}

%\floatstyle{boxed}
%\restylefloat{figure}

\lstset{basicstyle=\ttfamily\small}

\raggedbottom

\begin{document}

\title{The Shelley Network Layer\\
       {\small (Version 0.1)} \\
       {\large \sc An IOHK technical report}}
\author{Duncan Coutts \\ {\small \texttt{duncan@well-typed.com}} \\
                         {\small \texttt{duncan.coutts@iohk.io}}
   \and Alex Vieth \\ {\small \texttt{alex@well-typed.com}}
   \and Neil Davies \\ {\small \texttt{neil.davies@pnsol.com}} \\
                       {\small \texttt{neil.davies@iohk.io}}
   \and Marcin Szamotulski \\ {\small \texttt{marcin.szamotulski@iohk.io}}
   \and Karl Knutsson \\ {\small \texttt{karl.knutsson@iohk.io}}
   \and Marc Fontaine \\ {\small \texttt{marc.fontaine@iohk.io}}
   }
\date{December 20, 2018}

\maketitle

\begin{abstract}
  This document describes the Shelley network protocol.
\end{abstract}

\tableofcontents

\section*{Version history}

\begin{description}
\item[Version 0.1, Dez 20, 2018  Draft of the table of contents.]
                                  
\end{description}

\chapter{Overview}
\section{Scope}
\section{Layout of the Document}

\begin{itemize}
  \item What goes in which section ?
  \item In which order to read ?
  \item Which sections can be skipped ?
\end{itemize}

\section{Notation}

\chapter{Requirements}

\section{Performance Requirements and User Stories}
\subsection{Classes of Participants}
todo: make a nice table
\subsubsection{Stake pool} % lookup what this is called in the protocols.tex
\subsubsection{Small stakeholder}
\subsubsection{User who has delegated}
\subsubsection{Requiremts for Participants}
\subsubsection{Requiremts for Stake Pools}
\subsubsection{Services that the System should provide}

There are two kinds of Requirements:

\begin{enumerate}
\item System capabilities for a node to take a blockchain slot creation role in the protocol.
\item What services that the system provides to the user.
\end{enumerate}



\section{Protocol Updates on the Blockchain}
\begin{itemize}
\item Hydrid phase of federation and decentralization
\item Gradually transition between protocol variants on a life blockchain.
\item Several protocol variant active in parallel.
\item Communication between Shelley Nodes and existing core nodes.
\end{itemize}

\section{Node to Node and Node to Consumer IPC}
There are two basic variants of inter-process-communication in the network:
\begin{itemize}
\item IPC between Cardano nodes that are engaged in the high level Ouroboros
      blockchain consensus protocol.
\item IPC between a Cardano node and a `chain consumer' component such as a
      wallet, explorer or other custom application.
\end{itemize}
Both variants of IPC in the network follow destinct requirements and contraints, and
,while the first version of Cardano used a single protocol, the new version will
use different sets of protocols for both uses cases.
(See Section \ref{why_distinguish_protocols} for the motivation for this design decision.)
Throughout the document it will be clear which variant of we are referening to.

\section{Threat Model}
Todo: find out what a threat model is and whether it should be part of this document.
\subsection{Resource Consumption Attacks}


\section{Ouroboros}

How PoS is different from PoW in its network requirements:

\begin{itemize}
  \item No capability to sustain an undetected Eclipse attack
  \item Sustained liveness requirement
\end{itemize}

\section{Delegation}

\chapter{System Architecture}
\section{Overview}
\section{Design Choices}
\begin{itemize}
\item Only the design choices that have been taken.
\item Design discussions in the discussions section.
\end{itemize}
\section{Nodes}
\section{Protocol Layers}
\section{Components}\section{Interfaces Between the Layers}

\chapter{Infrastructure}
Specific assumptions about the infrastructure that are relevant for the discussion.

\section{Internet}
\section{Network Toplogy}
\section{Topographical distribution of block creating nodes}
\section{TCP}

\section{Operating Systems}
\section{Firewall}
\section{Nodes and Hosting}

\chapter{Protocols}
\subsection{Protocols as State-machines}
The reference implementation of serveral sub-protocols uses a generic framework
for state-machines.
Therefore it makes sense to also describe the protocols with a generic pattern,
that resembles the framework that is used for the implementation.
For each sub-protocol that is based on this underlying framework, the protocol description
will consist of the following items:

\begin{itemize}
\item An informal description of the protocol.
\item Who is communication.
\item Where is the protocol located the protocol stack.
\item States of the state-machine
\item The messages that are exchanged
\item A transition graph of the global view of the state machine.
\item A transition graph of the client view.
\item A transition graph of the server view.
\end{itemize}
  
\item The State Machine
  The Protocols are described as a state machine.
  The specification uses different representations of the state machine that all describe the same protocol
  but may leave out some aspects.
  \begin{itemize}
  \item The state machine can be represented as a collection of tables (States, Transitions/Messages..).
\end{itemize}

\item[States]
  We need to distinguish between the global state of a system
  which includes the values of all local variable stored on the nodes and
  the abstract states of the the state machines.
  The abstract states are equivalent classes of the global state.
  Every global state belongs to exactly one abstract state.
  This specification describes the state machine in terms of the abstract states.
  By definition, client and server are always in identical states
  which also means that client and server simultaneously transit to new states.
  The concrete implementation needs to relax the definition of state.
  In the concrete implementation the abstract view of state is replaced with
  client state and server state and transitions on either side happens independently
  when a message is send or received.
  While a message is in-flight the state of the receiver is undefined.(?)
  The state determines which side is active the client or the server.
\footnote{The Haskell implementation uses the concept of the dual of a state. Here it is sufficient to consider the state and the dual of the state as identical}


\item[Messages/Events]
  A tuple $(lable,data)$. Can be serialized transferred over the network and de-serialized.
  (authenticity of messages not handled here)
\item[Transitions]
  This part of the document describes the transitions of the abstract state of the protocol
  as the result of messages passed between client and the server.
  In sync with abstract state the  client and server update the local data to compute the
  the actual "outcome" of a protocol-run, for example "update the block chain".
  Parts of the local updates are specific to the implementation language and the underlying
  data structures, but they are also relevant for the protocol (to determine the next transition).
\end{description}

\subsection{Single Phase Chain Synchronization Protocol}
\subsubsection{Description}
\begin{description}
\item[purpose of the protocol]

The Chain Synchronization Protocol is used by the block chain consumer
to synchronize its block chain with the block chain producer.
It is polymorphic on blocks. And for some clients it will synchronize just headers (node-to-node),
for others it can be used to synchronize actual block (e.g., node-to-wallet).

\item[Who is communicating]
  A node communicates with several upstream and downstream node.
  The node runs an independent agents for every other node
  it communicates with. The typically a node runs agents where it acts as a server and also instances
  where it acts as a client.(See Figure \ref{chain-diagram-read-pointers}.)
\end{description}


\begin{description}
\item[purpose of the protocol]
The Chain Synchronization Protocol is used by the block chain consumer
to synchronize its block chain with the block chain producer.
\item[Who is communicating]
  A node communicates with several upstream and downstream node.
  The node runs an independent agents for every other node
  it communicates with. The typically a node runs agents where it acts as a server and also instances
  where it acts as a client.
\item[Where is located in the protocol stack ?]
\item[What are the interfaces to the lower layers of the stack ?]
  The chain synchronization protocol can send and receive messages. (via a point to point channel.)
\item[Initialization of an instance of the protocol]
\end{description}

\subsubsection{State machine}
\begin{figure}[H]
\begin{tabular}{|l|l|}
  \hline
  \multicolumn{2}{|c|}{States} \\ \hline
  Name  & Agency \\ \hline \hline
  Idle       & client \\ \hline
  CanAwait   & server \\ \hline
  MustReply  & server \\ \hline
  Intersect  & server \\ \hline
  Done       &        \\ \hline
  \hline
\end{tabular}
\end{figure}

\begin{figure}[H]
\begin{tabular}{|l|l|l|l|}
  \hline
  \multicolumn{4}{|c|}{Transitions} \\ \hline
  message/event      & parameter              & from        & to       \\ \hline\hline
  RequestNext        &                        & Idle        & CanAwait \\ \hline
  AwaitReply         &                        & CanAwait    & MustReply \\ \hline
  RollForward        & $header$,$point$       & CanAwait    & Idle \\ \hline
  RollForward        & $header$,$point$       & MustReply   & Idle \\ \hline
  RollBackward       & $header$,$point$       & CanAwait    & Idle \\ \hline
  RollBackward       & $point$,$point$       & MustReply    & Idle \\ \hline
  FindIntersect      & $points$               & Idle        & Intersect \\ \hline
  IntersectImproved  & $point_1$,$point_2$     & Intersect   & Idle \\ \hline
  IntersectUnchanged & $point$                 & Intersect   & Idle \\ \hline
  Done               &                         & Idle        & Done \\ \hline
\end{tabular}
\end{figure}

Client states are green and server states blue.
Arrows denote state transitions of the abstract state and \emph{not} the sender and receiver of messages.
In particular AwaitReply is a transition between the server states CanAwait and MustReply
but the corresponding message is send from the server to the client.

\begin{figure}[H]
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=4.5cm, semithick]
  \tikzstyle{every state}=[fill=red,draw=none,text=white]
  \node[state, green, initial]                                   (Idle)      {Idle};
  \node[state, right of=Idle]                             (Done)      {Done};
  \node[state, blue, below left of=Idle]                        (CanAwait)  {CanAwait};
  \node[state, blue, right of=CanAwait]                         (MustReply) {MustReply};
  \node[state, blue, above of=Idle]                        (Intersect) {Intersect};

%  MsgRequestNext :: ChainSyncMessage header point StIdle (StNext StCanAwait)
  \draw (Idle)         edge[left, bend right]      node{RequestNext}           (CanAwait);

%  MsgAwaitReply :: ChainSyncMessage header point (StNext StCanAwait) (StNext StMustReply)
  \draw (CanAwait)     edge[above, bend right]     node{AwaitReply}            (MustReply);

%  MsgRollForward :: header -> point -> ChainSyncMessage header point (StNext any) StIdle
  \draw (CanAwait)     edge[above,bend right=45]     node{RollForward}           (Idle);
  \draw (MustReply)    edge[right,bend right=45]     node{RollForward}           (Idle);

%  MsgRollBackward :: point  -> point -> ChainSyncMessage header point (StNext any) StIdle
  \draw (CanAwait)     edge[above,bend right=80]     node{RollBackward}          (Idle);
  \draw (MustReply)    edge[right,bend right=80]     node{RollBackward}          (Idle);

%  MsgFindIntersect :: [point] -> ChainSyncMessage header point StIdle StIntersect
  \draw (Idle)         edge[right, bend right]    node{FindIntersect}         (Intersect);

%  MsgIntersectImproved  :: point -> point -> ChainSyncMessage header point StIntersect StIdle
  \draw (Intersect)    edge[above, bend right=45]    node[below = 4mm]{IntersectImproved}     (Idle);

%  MsgIntersectUnchanged :: point -> ChainSyncMessage header point StIntersect StIdle
  \draw (Intersect)    edge[above, bend right=80]    node[above = 4mm]{IntersectUnchanged}    (Idle);

%  MsgDone :: ChainSyncMessage header point StIdle StDone
  \draw (Idle)         edge[above]                node{Done}                  (Done);

\end{tikzpicture}
\end{figure}


\section{Chain Following Protocol}
\section{Block Retrieval Protocol}
\section{What other Protocols ?}
\section{Peer Discovery}
\section{Abstract and concrete representation}

\begin{itemize}
  \item IER - Information Exchange Requirement
  \item CBOR - https://tools.ietf.org/html/rfc7049
\end{itemize}

\begin{itemize}
  \item CBOR as the concrete representation for the information exchanges
  \item Haskell to CBOR 
\end{itemize}

\chapter{Haskell}
While the network protocol itself can be implemented in many programming languages,
it has been developed in parallel with the Haskell reference implementation.
In addition to the language agnostic protocol decription in the other parts of this document,
this section discusses key aspects of the Haskell implementation.
This section is most useful for people who work with the Haskell reference implementation and
may give some extra insights for anybody who is interested in implementing the network.
For understanding the protocol, it is save to skip this section.
\begin{figure}
\pgfdeclareimage[height=10cm]{node-diagram-concurency}{node-diagram-concurency.pdf}
\begin{center}
\pgfuseimage{node-diagram-concurency}
\end{center}
\caption{Dataflow within a node.}
\label{node-diagram-concurency}
\end{figure}
\subsection{Constant Memory Consumption}

\chapter{Discussion}
Alternative view: Exploratory work.
The real work goes here
The Why is at least as important as the What.
\section{Overview}
\section{Design Discussion}
\subsubsection{Why distinguish between node to node and node-to-consumer IPC}
\label{why_distinguish_protocols}
We use two different sets of protocols for the these two use cases.

\begin{description}
\item[node-to-node] IPC beween nodes that are engaged in the high level Ouroboros
      blockchain consensus protocol.
\item[node-to-consumer] IPC between a Cardano node and a `chain consumer' component such as a
      wallet, explorer or other custom application.
\end{description}

This section describes the differences between those two variants of IPC and why both use
different protocols.

The node-to-node protocol is conducted in a P2P environment
with very limited trust between peers. The node-to-node protocol utilises
store-and-forward over selected \emph{bearers} which form the underlying
connectivity graph. A concern in this setting is asymmetric resource consumption
attacks. Ease of implementation is a nice to have, but is subordinate to the
other hard constraints.

A node-to-consumer protocol is intended to support blockchain applications
like wallets and explorers, or Cardano-specific caches or proxies. The setting
here is that a consumer trusts a node (a `chain producer') and just wants to
catch up and keep up with the blockchain of that producer. It is assumed that
a consumer only consumes from one producer (or one of a related set of
producers), so unlike in the node-to-node protocol there is no need to choose
between different available chains. The producer may still not fully trust the
consumer and does not want to be subject to highly asymmetric resource
consumption attacks. In this use case, because of the wider range of
applications that wish to consume the blockchain, having some options that are
easy to implement is more important, even if this involves a trade-off with
performance. That said, there are also use cases where tight integration is
possible and making the most efficient use of resources is more desirable.

There are a number of applications that simply want to consume the blockchain,
but are able to rely on an upstream trusted or semi-trusted Cardano consensus
node. These applications do not need to engage in the full consensus protocol,
and may be happy to delegate the necessary chain validation.

Examples include 3rd party applications that want to observe the blockchain,
examples being business processes triggered by transactions or analytics.  It
may also include certain kinds of light client that wish to follow the
blockchain but not do full validation.

Once one considers a node-to-consumer protocol as a first class citizen then it
opens up opportunities for different system architecture choices.
The architecture of the original Cardano Mainnet release was entirely homogeneous:
every node behaved the same, each trusted nothing but itself and paid the full
networking and processing cost of engaging in the consensus protocol.  In
particular everything was integrated into a single process: the consensus
algorithm itself, serving data to other peers and components such as the wallet
or explorer. If we were to have a robust and efficient node-to-consumer protocol
then we can make many other choices.

With an efficient \emph{local} IPC protocol we can have applications
like wallets and explorers as separate processes. Even for tightly
integrated components it can make sense to run them in separate OS
processes and the associated OS mamagement tools. Not only is the
timing constraints for a consensus node are much easier to manage when
it does not have to share CPU resources with chain consumers, but it
enables the use of operating system features to give finer control
over resource consumption for sophisticated end-users.  There have
been cases in production where a highly loaded wallet component takes
more than its allowed allocation of CPU resources and causes the local
node to miss its deadlines.  By giving a consensus node a dedicated
CPU core it becomes more plausible to provide the necessary hard real
time guarantees. In addition, scaling on multi-core machines is
significantly easier with multiple OS processes than with a
multi-threaded OS process with a shared-heap. This could allow for
larger capacity Cardano relay deployments where there are multiple
network facing proxy processes that all get their chain from a single
local consensus node.

With an efficient \emph{network} IPC protocol we can do similar things
but extend it across multiple machines. This permits: large
organisations to achieve better alignment with their security
policies; clusters of relays operated by a single organisation to use
the more efficient (less resource costly) node-to-consumer protocol
instead of the node-to-node protocol; Similarly it allows for wallet
or explorer-like applications that need to scale out, and are able to
make use of a trusted node.

\section{Requirements}
\section{Threat Vectors}
\subsubsection{Asymptotic Resource consumption}
\section{Results from Simulations}
\section{Pub Sub}
\section{Of the Shelf Protocols}
\section{Meta Requirements}
\subparagraph{Work in Progress}
This document is evolved in parallel with the work on the protocol design and
the reference implementation.

\subparagraph{The Document should be Comprehensive}
\begin{itemize}
\item Top down approach.
\item Provide the big picture.
\item Usable as a reference point for a broader discussion.
\item Cover every aspect that is related to network connections.
\item Every aspect should at least have a place in the table of contents.
  If there are holes and parts that are not covered the document should say what is missing.
\item Stand alone readable with links to where missing pieces can be found.
\end{itemize}

\subparagraph{Detailed}
\begin{itemize}
\item Sufficient details to allow for new independent implementations that are compatible with
the reference implementation
\item Language agnostic (it is save to skip the Haskell specific parts)
\item Design discussions
\end{itemize}
\subparagraph{Structured}
\begin{itemize}
\item Parts of the document should be in a logical connection
\end{itemize}
\subparagraph{Workflow}

\bibliographystyle{apalike}
\bibliography{references}

\appendix

\end{document}
