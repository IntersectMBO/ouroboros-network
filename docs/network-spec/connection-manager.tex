% TODO:
% Discussion of interaction between inbound protocol governor and connection
% manager when a new outbound connection is requested.

% TODO:
% I realised that it would be nicer to structure the spec a bit differently.
% First, describe each transition in general terms, without referring to the
% implementation, and in a subsequent section, introduce implementation details.

\chapter{Connection Manager State Machine Specification}
\label{chapter:connection-manager}

\tikzstyle{decision} =
  [ diamond
  , fill=DarkSeaGreen1
  , text width=4.5em
  , text badly centered
  , node distance=3cm
  , inner sep=0pt
  ]
\tikzstyle{outbound_state} =
  [ rectangle
  , rounded corners
  , fill=DodgerBlue1
  , minimum height=2em
  ]
\tikzstyle{inbound_outbound_state} =
  [ rectangle
  , rounded corners
  , fill=HotPink3
  , minimum height=2em
  ]
\tikzstyle{inbound_state} =
  [ rectangle
  , rounded corners
  , fill=DarkOliveGreen3
  , minimum height=2em
  ]
\tikzstyle{impossible_outbound_state} =
  [ rectangle
  , rounded corners
  , fill=LightBlue2
  , rounded corners
  , minimum height=2em
  ]
\tikzstyle{line} =
  [ draw
  , -latex'
  ]
\tikzstyle{error} =
  [ rectangle
  , rounded corners
  , fill=red!255!blue!20
  , minimum height=2em
  ]
\tikzstyle{requestOutboundArr}      = [ color = DodgerBlue1 ]
\tikzstyle{registerInboundArr}      = [ color = HotPink3 ]
\tikzstyle{promotedToWarmRemoteArr} = [ color = DarkOliveGreen3 ]
\tikzstyle{demotedToColdRemoteArr}  = [ color = Orange2 ]
\tikzstyle{unregisterOutboundArr}   = [ color = Turquoise ]
\tikzstyle{unregisterInboundArr}    = [ color = DarkOrchid2 ]

\def\TCP{\textsf{TCP}}
\def\ipvfour{\textsf{ipv4}}
\def\ipvsix{\textsf{ipv6}}

% Connection manager's states
\def\InitialState{\textbullet}
\def\FinalState{\textbullet}
\def\ReservedOutboundState{\texttt{ReservedOutboundState}}
\def\UnnegotiatedStateOut{\texttt{UnnegotiatedState Outbound}}
\def\UnnegotiatedStateIn{\texttt{UnnegotiatedState Inbound}}
\def\UnnegotiatedStateAny{\texttt{UnnegotiatedState prov}}
\def\OutboundStateUni{\texttt{OutboundState Unidirectional}}
\def\OutboundStateDup{\texttt{OutboundState Duplex}}
\def\OutboundStateDupTau{\texttt{OutboundState\textsuperscript{$\tau$} Duplex}}
\def\OutboundStateDupP{\texttt{OutboundState\phantom{\textsuperscript{$\tau$}} Duplex}}
\def\OutboundStateUniTau{\texttt{OutboundState\textsuperscript{$\tau$} Unidirectional}}
\def\OutboundStateAny{\texttt{OutboundState dataFlow}}
\def\OutboundStateAnyTau{\texttt{OutboundState\textsuperscript{$\tau$} dataFlow}}
\def\DuplexState{\texttt{DuplexState}}
\def\InboundStateUni{\texttt{InboundState Unidirectional}}
\def\InboundStateDup{\texttt{InboundState Duplex}}
\def\InboundStateAny{\texttt{InboundState dataFlow}}
\def\WaitRemoteIdle{\texttt{WaitRemoteIdleState}}
\def\InboundIdleStateUni{\texttt{InboundIdleState\textsuperscript{$\tau$} Unidirectional}}
\def\InboundIdleStateDup{\texttt{InboundIdleState\textsuperscript{$\tau$} Duplex}}
\def\InboundIdleStateAny{\texttt{InboundIdleState\textsuperscript{$\tau$} dataFlow}}
\def\OutboundIdleStateUni{\texttt{OutboundIdleState\textsuperscript{$\tau$} Unidirectional}}
\def\OutboundIdleStateDup{\texttt{OutboundIdleState\textsuperscript{$\tau$} Duplex}}
\def\OutboundIdleStateAny{\texttt{OutboundIdleState\textsuperscript{$\tau$} dataFlow}}
\def\TerminatingState{\texttt{TerminatingState\textsuperscript{$\tau$}}}
\def\TerminatedState{\texttt{TerminatedState}}

% Connection manager's transitions
\def\Reserve{\textsf{Reserve}}
\def\Connected{\textsf{Connected}}
\def\Accepted{\textsf{Accepted}}
\def\Overwritten{\textsf{Overwritten}}
\def\NegotiatedUniOut{\textsf{Negotiated}\textsuperscript{\textsf{Unidirectional}}\textsubscript{\textsf{Outbound}}}
\def\NegotiatedDupOut{\textsf{Negotiated}\textsuperscript{\textsf{Duplex}}\textsubscript{\textsf{Outbound}}}
\def\NegotiatedUniIn{\textsf{Negotiated}\textsuperscript{\textsf{Unidirectional}}\textsubscript{\textsf{Inbound}}}
\def\NegotiatedDupIn{\textsf{Negotiated}\textsuperscript{\textsf{Duplex}}\textsubscript{\textsf{Inbound}}}
\def\SelfNegotiatedUniIn{\textsf{SelfNegotiated}\textsuperscript{\textsf{Unidirectional}}\textsubscript{\textsf{Inbound}}}
\def\SelfNegotiatedDupIn{\textsf{SelfNegotiated}\textsuperscript{\textsf{Duplex}}\textsubscript{\textsf{Inbound}}}
\def\NegotiatedAnyIn{\textsf{Negotiated}\textsuperscript{\textsf{dataFlow}}\textsubscript{\textsf{Inbound}}}
\def\PromotedToWarmDupLoc{\textsf{PromotedToWarm}\textsuperscript{\textsf{Duplex}}\textsubscript{\textsf{Local}}}
\def\PromotedToWarmDupRem{\textsf{PromotedToWarm}\textsuperscript{\textsf{Duplex}}\textsubscript{\textsf{Remote}}}
\def\PromotedToWarmAnyRem{\textsf{PromotedToWarm}\textsuperscript{\textsf{dataFlow}}\textsubscript{\textsf{Remote}}}
\def\DemotedToColdDupLoc{\textsf{DemotedToCold}\textsuperscript{\textsf{Duplex}}\textsubscript{\textsf{Local}}}
\def\DemotedToColdAnyLoc{\textsf{DemotedToCold}\textsuperscript{\textsf{dataFlow}}\textsubscript{\textsf{Local}}}
\def\DemotedToColdDupRem{\textsf{DemotedToCold}\textsuperscript{\textsf{Duplex}}\textsubscript{\textsf{Remote}}}
\def\TimeoutExpired{\textsf{TimeoutExpired}}
\def\DemotedToColdAnyRem{\textsf{DemotedToCold}\textsuperscript{\textsf{dataFlow}}\textsubscript{\textsf{Remote}}}
\def\DemotedToColdUniLoc{\textsf{DemotedToCold}\textsuperscript{\textsf{Unidirectional}}\textsubscript{\textsf{Local}}}
\def\DemotedToColdUniRem{\textsf{DemotedToCold}\textsuperscript{\textsf{Unidirectional}}\textsubscript{\textsf{Remote}}}
\def\Restart{\textsf{Restart}}
\def\Prune{\textsf{Prune}}
\def\CommitDupRem{\textsf{Commit}\textsuperscript{\textsf{Duplex}}\textsubscript{\textsf{Remote}}}
\def\CommitUniRem{\textsf{Commit}\textsuperscript{\textsf{Unidirectional}}\textsubscript{\textsf{Remote}}}
\def\CommitAnyRem{\textsf{Commit}\textsuperscript{\textsf{dataFlow}}\textsubscript{\textsf{Remote}}}
\def\AwakeDupRem{\textsf{Awake}\textsuperscript{\textsf{Duplex}}\textsubscript{\textsf{Remote}}}
\def\AwakeUniRem{\textsf{Awake}\textsuperscript{\textsf{Unidirectional}}\textsubscript{\textsf{Remote}}}
\def\AwakeAnyRem{\textsf{Awake}\textsuperscript{\textsf{dataFlow}}\textsubscript{\textsf{Remote}}}
\def\AwakeDupLoc{\textsf{Awake}\textsuperscript{\textsf{Duplex}}\textsubscript{\textsf{Local}}}
\def\CommitAnyLoc{\textsf{Commit}\textsuperscript{\textsf{dataFlow}}\textsubscript{\textsf{Local}}}
\def\CommitDupLoc{\textsf{Commit}\textsuperscript{\textsf{Duplex}}\textsubscript{\textsf{Local}}}
\def\CommitUniLoc{\textsf{Commit}\textsuperscript{\textsf{Unidirectional}}\textsubscript{\textsf{Local}}}
\def\Terminate{\textsf{Terminate}}
\def\Timeout{\textsf{Timeout}}
\def\SelfConn{\textsf{SelfConn}}
\def\SelfConnRev{\textsf{SelfConn$^{-1}$}}
\def\SelfConnPrim{\textsf{SelfConn'}}
\def\SelfConnPrimRev{\textsf{SelfConn'$^{-1}$}}

% Inbound governor states
\def\RemoteEstablished{\textsf{RemoteEstablished}}
\def\RemoteIdle{\textsf{RemoteIdle}\textsuperscript{$\tau$}}
\def\RemoteCold{\textsf{RemoteCold}}
\def\RemoteWarm{\textsf{RemoteWarm}}
\def\RemoteHot{\textsf{RemoteHot}}

% Inbound governor transitions
\def\NewInboundConnection{\textsf{NewConnection Inbound}}
\def\NewOutboundConnection{\textsf{NewConnection Outbound}}
\def\NewConnection{\textsf{NewConnection}}
\def\NewConnectionAny{\textsf{NewConnection provenance}}
\def\AwakeRemote{\textsf{AwakeRemote}}
\def\RemoteToCold{\textsf{RemoteToCold}}
\def\CommitRemote{\textsf{CommitRemote}}
\def\MiniProtocolTerminated{\textsf{MiniProtocolTerminated}}
\def\MuxTerminated{\textsf{MuxTerminated}}
\def\PromotedToHotRemote{\textsf{PromotedToHotRemote}}
\def\DemotedToWarmRemote{\textsf{DemotedToWarmRemote}}
\def\WaitIdleRemote{\textsf{WaitIdleRemote}}

% Peer states
\def\cold{\textit{cold}}
\def\warm{\textit{warm}}
\def\hot{\textit{hot}}
\def\established{\textit{established}}

% Protocol names
\def\keepAlive{\textsf{keep-alive}}
\def\tipSample{\textsf{tip-sample}}

% Component names
\def\ptopgov{\textit{p2p governor}}
\def\mux{\textit{mux}}
\def\inbgov{\textit{inbound protocol governor}}
\def\Inbgov{\textit{Inbound protocol governor}}
\def\connmngr{\textit{connection manager}}
\def\Connmngr{\textit{Connection manager}}
\def\True{\texttt{True}}
\def\False{\texttt{False}}

% TODO notes for the implementation
\newcommand{\todoimpl}[1]{\todo[backgroundcolor=red,linecolor=red]{#1}}

\section{Introduction}

As described in the \href{https://ouroboros-network.cardano.intersectmbo.org/pdfs/network-design}{Network Design} document, the goal is to transition to a more
decentralised network. To make that happen, a plan was designed to come up with a P2P
network that is capable of achieving desired network properties. One key component of
such design is the \ptopgov{}, which is responsible for managing the \cold{}/\warm{}/\hot{}
peer selection, managing the churn of these groups, and adjusting the targets in order for
the network to reach the desired properties. However, having \warm{} and \hot{} peers implies
establishing a bearer connection; \hot{} peers need to run several mini-protocols, and each
mini-protocol runs two instances (client and server). This means that with a large enough
warm/hot peer target, there's going to be a lot of resource waste when it comes to file
descriptor usage. There's also the problem of firewalls, where it matters who tries to
start a communication with whom (if it's the client or the server).

Knowing this, it would be good to make the most of each connection and, in order to do so, the
\Connmngr{} was designed.

\section{Components}
Figure \ref{tik:components} illustrates the three main components of the decentralisation
process from the perspective of a local node. In the \texttt{Outbound} side, the
\ptopgov{}, as said previously, takes care of all connection initiation (outbound
connections) and decides which mini-protocols to run (\established{}, \warm{} or \hot{}).
In the \texttt{Inbound} side, the \texttt{Server} is just a simple loop, responsible for accepting incoming
connections; and the \texttt{Inbound Protocol Governor} role is starting/restarting the required
mini-protocols, to detect if its local peer was added as a \warm{}/\hot{}
peer in some other remote node and to set timers in some cases, e.g. if the
remote end opened a connection and did not send any message; the
\texttt{Inbound Protocol Governor} will timeout after some time and close the
connection. The arrows in Figure \ref{tik:components} represent dependencies
between components: The server accepts a connection, which is then given to
\Connmngr{}. \Connmngr{} exposes methods to update its state whenever the
\texttt{Inbound Protocol Governor} notices that the connection was used (could
be used due to \warm{}\\hot{} transitions).  If peer sharing is enabled, the
incoming address will eventually be added to the known set of the outbound
governor.

\begin{figure}[h]
  \footnotesize
  \def\xa{-2.0}
  \def\xb{2.0}
  \begin{tikzpicture}
    \node at (-3.25, 1.6)  {\textit{Outbound side}};
    \node at ( 3.25, 1.6)  {\textit{Inbound side}};

    \node[rounded corners, rectangle, draw, minimum height=3cm,anchor=east, text width=4cm] (outbound_governor) at (\xa, -3)
     {
       \hfil\textbf{Outbound Governor}\hfil\\
       \setlength{\leftmargini}{15pt}
       \begin{itemize}
        \item manages connection initiation (dual of accepting a connection)
        \item runs and monitors initiator protocols on unidirectional or duplex connections
        \item notify the inbound governor about outbound duplex connections
      \end{itemize}
      \vspace{5pt}
      };

    \node[rounded corners, rectangle, draw, anchor=west, text width=4cm] (server) at (\xb, 0.30)
      {
        \hfill{\textbf{Server}}\hfill
        \vspace{0.2em}
        \setlength{\leftmargini}{15pt}
        \begin{itemize}
          \item accepts connections
          \item performs some amount of dynamic rate limiting
        \end{itemize}
        \vspace{5pt}
      };

    \node[rounded corners, rectangle, draw, anchor=west, text width=4cm] (inbound_governor) at (\xb, -5)
      {
        \hfill{\textbf{Inbound Protocol Governor}}\hfill
        \vspace{0.2em}
        \setlength{\leftmargini}{15pt}
        \begin{itemize}
          \item start/restart responder mini-protocols on inbound and
            outbound duplex connections
          \item detects when all server/responder
            mini-protocols are idle, after an inactivity period, connection
            manager is notified
          \item detects inactivity on just accepted connections and asks the
            connection manager to release it if a timeout expired
          \item pass addresses of inbound connections to the outbound governor (light peer sharing)
        \end{itemize}
        \vspace{5pt}
      };

    \node[rounded corners, rectangle, draw, minimum height=1cm, text width=2cm] (connection_manager) at (0, -3)
      {
        \hfil\textbf{Connection}\hfil\\
        \hfil\textbf{Manager}\hfil
      };

    \draw[<-] (outbound_governor)            -- (connection_manager);
    \draw[->] (server)                       -- (inbound_governor);
    \draw[<->] (connection_manager.355)      -- (inbound_governor.138);
    \draw[->,dashed] (inbound_governor.170)  --node[below]{\footnotesize{light peer sharing}} (outbound_governor.322);
  \end{tikzpicture}
  \caption{Main components}
  \label{tik:components}
\end{figure}

Using a TCP connection in both directions rather than two independent TCP
connections is suitable for efficient use of network resources, but more importantly,
it is crucial to support certain essential scenarios where one node is behind a
firewall that blocks incoming TCP connections. For example, it is good practice
to have a block-producing node behind a firewall while deploying relay nodes
outside of it. If the node behind the firewall can establish an outbound
TCP connection to its relays but still has those relays select the
block-producing node as an upstream peer, which means that node operators do
not need to configure any holes and/or port forwarding in the firewall. If we
were only to support running mini-protocols in one direction, then this scenario
would require a hole in the firewall to allow the relays to establish incoming
connections to the block-producing node. That would be both less secure and also
require additional configuration.

Consider, however, what is required to make this scenario work.
\begin{enumerate}
\item We must start with an outbound connection being established from the
      block-producing node to a relay.
\item The block-producing node wants the relay as an upstream peer -- to
      receive blocks from the rest of the network -- so the normal
      mini-protocols need to be run with the block-producing node in the client
      role and relay in the server role. So initially, at least, the relay had to
      act as a server to accept the connection and to run the server side of
      the mini-protocols.
\item Next, however, we want the relay to be able to select the block-producing
      node as an upstream peer, and we want it to do so by reusing the existing
      connection since we know the firewall makes it impossible to establish a
      new outbound connection to the block-producing node. Thus, we must be able
      to have the relay start the client side of the usual mini-protocols and
      The block-producer must be running on their server side.
\item So, notice that this means we have started with just running the
      mini-protocols in one direction and transitioned to running them in both
      directions, what we call full \emph{duplex}.
\item Furthermore, such transitions are not a one-off event. It is entirely
      possible for a node to select another peer as an upstream peer and later
      change its mind. This means we could transition from duplex back to
      unidirectional -- and that unidirectional direction need not even be the
      same as the initial direction!
\end{enumerate}
This leads to a couple of observations:
\begin{enumerate}
\item that, in the general case, we need to support any number of transitions
      between unidirectional and duplex use of a connection and
\item that once a bearer has been established, the relationship between the two
      ends is symmetric: the original direction hardly matters.
\end{enumerate}

A consequence of all this is that we cannot use a classic client/server design.
We are decoupling the ongoing role of the connection from who initiated it.
That is, we cannot just run a server component that manages all the connections
and threads for the server (inbound) side of things and a separate component
that manages the connections and threads for the client (outbound) side of
things. The connections have to be a shared resource between the inbound and
outbound sides so that we can use connections in either or both directions
over the lifetime of a connection.

Although actual TCP connections must be a shared resource, we do not wish to
Intermingle the code to handle the inbound and outbound directions. As noted
above, the selection of upstream (outbound) peers is quite complicated, and we
would not want to add to that complexity by mixing it with a lot of other
concerns, and vice versa.
To minimise complexity, it would be preferable if the code that manages
the outbound side would be completely unaware of the inbound side and vice
versa. Yet, we still want the inbound and outbound sides to opportunistically
share TCP connections where possible. This appears to be eminently achievable
given that we are using multiplexing to run mini-protocols in either direction
and concurrency for mini-protocol handlers to achieve a degree of modularity.

The use of a single TCP connection helps simplify exception processing
and mitigate poor peer performance in a timely manner (whether connection-related or
otherwise). This is covered in more detail in \cref{sec:exceptions}.

These ideas lead to the design illustrated in \cref{tik:components}. In this
design, there is an outbound and inbound side -- which are completely unaware of
each other -- mediated by a shared \emph{connection manager} component.

The connection manager is there to manage the underlying TCP connection
resources. It has to provide an interface to the outbound side to enable the
use of connections in an outbound direction. Correspondingly, it must provide an
interface to the inbound side to enable the use of connections in an inbound
direction. Internally, it must deal with connections being used in a
unidirectional or duplex way, as well as the transitions between them. Of course, it
can be the case that connections are no longer required in either direction,
and such connections should be closed in an orderly manner. This must be the
responsibility of the connection manager since it is the only component that
can see both inbound and outbound sides to be able to see that a connection is
no longer needed in either direction and, hence, not needed at all.

In the next couple of sections, we will review the inbound and outbound sides
need to be able to do, and what service does the connection manager need to provide?

\section{Exception Processing}
\label{sec:exceptions}

We maintain a one-to-one correspondence between peers and connections, which
simplifies exception handling since if there's a single mini-protocol
violation, we need to shut down the thread that handles that particular
connection.  Although multiple threads handle a single connection: two
threads per a pipelined mini-protocol, one thread per a non-pipelined one, plus
two multiplexer threads (muxer \& demuxer threads).  However, all these threads
are spawned and managed by the multiplexer, which has the property that if any
of the threads throws an exception, all of the threads will be killed.  This
property allows us to have a single error handling policy (called
\href{https://ouroboros-network.cardano.intersectmbo.org/ouroboros-network-framework/Ouroboros-Network-RethrowPolicy.html\#t:RethrowPolicy}{\texttt{RethrowPolicy}})
per connection handler thread. A \texttt{RethrowPolicy} classifies exceptions
into two categories, depending on whether an exception should terminate the
connection or be propagated to terminate the whole process.
\texttt{RethrowPolicy}-ies can be composed in terms of a semi-group.  Network
code only makes \texttt{IOManagerError}s fatal.  On top of that, consensus
introduces its own
\href{https://ouroboros-consensus.cardano.intersectmbo.org/haddocks/ouroboros-consensus-diffusion/Ouroboros-Consensus-Node-RethrowPolicy.html\#v:consensusRethrowPolicy}{\texttt{consensusRethrowPolicy}}
for the Node-To-Node protocol.

\section{Mini-protocol return values}
\label{sec:mini-protocol-return-values}

Handling of mini-protocol return values is a complementary feature to exception
processing, hence it's described here, although it is done at the
Outbound-Governor level rather than Connection-Manager level, which is primarily
described in this part of the documentation.

We classify mini-protocol return values for initiator/client mini-protocols
(this feature is only needed for the \textit{chain-sync
mini-protocol}). For a given return value, we compute the re-promotion delay used by
the Outbound-Governor. Here is the
\href{https://ouroboros-consensus.cardano.intersectmbo.org/haddocks/ouroboros-consensus-diffusion/Ouroboros-Consensus-Node-ExitPolicy.html\#v:returnPolicy}{\texttt{returnPolicy}}.
introduced in Ouroboros-Consensus for the Node-To-Node protocol.  Cardano-Node
is not managing outbound node-to-client connection; hence, a policy for
the node-to-client protocol is not needed.

The outbound governor is also given a policy which controls how long to wait
until re-promote a peer after an exception (for now, we use a fixed delay).

\section{Outbound side: the outbound governor}

A key component of the design for decentralisation is the outbound governor. It
is responsible for:
\begin{itemize}
\item managing the selection of upstream peers;
\item managing the transitions of upstream peers between cold/warm/hot states;
\item continuously making progress towards the target number of peers in each
      state; and
\item adjusting these targets over time to achieve a degree of `churn'.
      \todo[inline]{cross reference}
\end{itemize}
Taken together, and with appropriate policies, a network of nodes should be
able to self-organise and achieve the desired properties. We have simulation
results that give us a good degree of confidence that this is indeed the case
at a large scale.

Fortunately, while the outbound governor's decision-making procedures are relatively
complex, the use of connections is quite simple. The governor needs only two
interactions.
\begin{description}
\item[Acquire a connection.] The governor decides when to promote a peer from
  cold to warm. To perform the promotion, it needs to acquire access to a
  connection -- either fresh or pre-existing. To complete the promotion, the client side of warm mini-protocols will be started.

\item[Release a connection.] The governor also decides when to demote a peer to
  cold. As part of the demotion, the client-side mini-protocols are terminated.
  The connection is then no longer needed by the governor and is released.
\end{description}

It is worth noting again that the outbound governor does not require exclusive
access to the TCP bearer. It has no special TCP-specific needs during setup or
shutdown.
It needs access to the multiplexer to be able to run a set of
mini-protocols in one direction. So, in a sense, it needs exclusive access to
`half' of a multiplexer for a connection, but it does not need to coordinate with or
even be aware of any use of the other `half' of the multiplexer. It is this
separation of concerns that enables a modular design and implementation.


\section{Inbound side: the server}

The inbound side has a less complex task than the outbound governor, but its
interactions with the connection manager are slightly more complicated.

The inbound side is split into two components: the server and the inbound governor.

The server is responsible for accepting new TCP connections on the listening
socket. It is responsible for not exceeding resource limits by accepting too
many new connections. It is also responsible for a little bit of DoS protection:
limiting the rate of accepting new connections.

The server component is much simpler than in most network server applications
because it does not need to manage the connection resources once created. The
server hands new connections over to the connection manager as soon as they are
accepted. The server's responsibilities end there. The server needs only two
interactions with the connection manager.
\begin{description}
\item[Query number of connections] The server component needs to query the
  connection manager to find the current number of connections. It uses this
  information to decide if any new connections can be accepted or if we are
  at the resource limits. Below the hard limits, the current number can be used
  as part of rate-limiting decisions.

\item[Hand over a new connection] Once the server component has successfully
  accepted a new connection, it needs to hand over responsibility for it to
  the connection manager.
  \todo[inline]{be clearer in the responsibilities and the conditions that should hold}
\end{description}


\section{Inbound side: the inbound governor}
\todo[inline]{this section needs to be clearer about assumed pre-conditions and
      intended post-conditions}

The inbound governor is responsible for starting, restarting and monitoring the
the server side of the mini-protocols.

One of the high-level design choices is that when a server-side mini-protocol
terminates cleanly (usually because the client chose to terminate it), then the
the server side of the mini-protocol should be restarted in its initial state in
case the client wishes to use the protocol again later. It is the inbound
governor that is responsible for doing this.

\todo[inline]{this mux interaction lifetime may benefit from a separate (sub-)section}
The mux component provides a mechanism to start mini-protocol handlers on a
connection for a specific mini-protocol number in a particular direction. These
handlers can then be monitored to see when they terminate. The inbound governor
relies on this mechanism to monitor when the protocol handler terminates
cleanly. When it does terminate cleanly, the governor restarts the mini-protocol
handler.

All the mini-protocols have the property that agency starts with the
client/initiator side\footnote{Originally transaction submission protocol had
agency start with the responder/server side. A later protocol update reversed
the initial agency so that they are now all consistent.}. This allows all of
the server/responder side protocols to be started in the mux `on-demand' mode.
In the on-demand mode, the protocol handler thread is not started until the
client's first message arrives. \todo[inline]{this lack of active
processing locally is used as a witness of remote peer idleness - where should
we be explicit about that?}

The inbound governor gets informed of new connections that should be monitored
either via the server or by the connection manager. The server informs the
governor about fresh inbound connections. The connection manager informs the
governor about connections that started due to a request for an outbound
connection -- at least for those connections that are to be available to use in
duplex mode.

% \begin{designalternative}
As illustrated in \cref{tik:components}, both the connection manager and server
components communicate with the inbound governor directly. They do this to
inform the inbound governor about new connections so that it can start to run
and monitor the server-side protocols. The server notifies about new connections
established inbound, while the connection manager acquires new connections
established outbound (at least the duplex ones) through the connection manager API.
A slight simplification would be to have only one of these routes of
notification.
% The more obvious choice would be for the connection manager to inform the
% inbound governor about all new connections. Then, the server would only
% interact with the connection manager and not with the inbound governor.
% \end{designalternative}

The inbound governor \todo[inline]{capture interfaces to other services}
\todo[inline]{express intended sequencing more clearly}

One simple illustration of how these three components interact together:

\begin{itemize}
    \item Server accepts a connection;
    \item Server registers that connection to the connection manager (which puts the
      connection in \UnnegotiatedStateIn{});
    \item Assuming the handshake was successful, the connection is put in
      \InboundIdleStateDup{};
    \item The remote end transitions the local node to warm (using the connection) within the expected timeout;
    \item IPG (Inbound Protocol Governor) notifies the \Connmngr{} about this state
      change, via \texttt{promotedToWarmRemote}. Now the connection is
      in \InboundStateDup{};
    \item \Connmngr{} is asked for an outbound connection to that peer (by the \ptopgov{}), it notices
      that it already has a connection with that peer in \InboundStateDup{}, so it gives
      that connection to \ptopgov{} and updates its state to \DuplexState{}.
\end{itemize}

You can find more information about the possible different connection states in the section
\ref{sec:connection-state}.

\section{Connection Manager}

\subsection{Overview}

\Connmngr{} is a lower-level component responsible for managing connections and its
resources. Its responsibilities consist of:

\begin{itemize}
    \item Tracking each connection, in order to keep an eye on the bounded resources;
    \item Starting new connections, negotiating if the connection should be
      \emph{full-duplex} or \emph{half-duplex}, through the \emph{Connection Handler};
    \item Be aware of \warm{}/\hot{} transitions, in order to try and reuse already established
      connections;
    \item Negotiating which direction, which mini-protocol is going to run
      (Client $\rightarrow$ Server, Server$\rightarrow$Client, or both);
    \item Taking care of a particularity of TCP connection termination (lingering
      connections).
\end{itemize}

The \Connmngr{} creates and records accepted connections and keeps track of their state
as negotiations for the connection and start/stop mini-protocols are made. There's an
\emph{internal state machine} that helps the \Connmngr{} keep track of the state of each
connection, and help it make decisions when it comes to resource management and
connection reusing.

The \emph{Connection Handler} drives through handshake negotiation and starts the multiplexer. The
the outcome of the handshake negotiation is:

\begin{itemize}
    \item the negotiated version of the protocol
    \item negotiated parameters, which include the mode in which the connection will be
      run (\texttt{InitiatorOnlyMode}, \texttt{ResponderOnlyMode},\\
      \texttt{InitiatorAndResponderMode} - the first two are \emph{half-duplex}, the last
      one is \emph{full-duplex} mode)
    \item Handshake might error
\end{itemize}

\begin{figure}
    \centering
    \includegraphics[width=\linewidth]{figure/node-to-node-ipc.png}
    \caption{Duplex connection running several mini-protocols}
    \label{fig:protocol-diagram}
\end{figure}

The \emph{Connection Handler} notifies the \Connmngr{} about the result of a negotiation, which
triggers a state transition. If we can run the connection in full-duplex mode,
then it is possible to run the bundles of mini-protocols in both directions and otherwise only in one direction.
So, Figure \ref{fig:protocol-diagram} shows $6$ mini protocols running, $3$ in each direction.
If we negotiated only a unidirectional connection, then we'd only be running $3$
(The direction is based on which peer established the connection).

From the point of view of the \connmngr{}, it only
matters whether an \emph{unidirectional} or \emph{duplex} connection was negotiated.
Unidirectional connections are the ones that run exclusively on either the initiator or responder
side of mini-protocols, while duplex connections can run either or
both initiator and responder protocols. Note that in the outbound direction (initiator side),
it is the \ptopgov{} responsibility to decide which set of mini-protocols:
\established{}, \warm{} or \hot{}, are running. On the inbound side (responder
mini-protocols), we have no choice but to run all of them.

The \connmngr{} should only be run in two \texttt{MuxMode}s:

\begin{itemize}
  \item \texttt{ResponderMode} or
  \item \texttt{InitiatorAndResponderMode}
\end{itemize}

\noindent, the \texttt{InitiatorMode} is not allowed, since that mode is reserved for
special leaf nodes in the network (such as the blockchain explorer, for example), and it doesn't make
sense to run a node-to-client client side.

The duplex mode: \texttt{InitiatorAndResponderMode} is useful for managing
connection with external nodes (\textit{node-to-node protocol}), while
\texttt{ResponderMode} is useful for running a server which responds to local
connections (server side of \textit{node-to-client protocol}).


\Connmngr{} can use at most one \ipvfour{} and at most one \ipvsix{}
address. It will bind to the correct address depending on the remote address
type (\ipvfour{}/\ipvsix{}).

In this specification, we will often need to speak about two nodes communicating
via a \TCP{} connection.  We will often call them local and remote ends of the
connection or local \slash{} remote nodes; we will usually take the
perspective of the local node.


\subsection{Types} % Not sure about this naming

\Connmngr{} exposes two methods to register a connection:

\begin{lstlisting}
data Connected peerAddr handle handleError
  -- | We are connected, and mux is running.
  = Connected    !(ConnectionId peerAddr) !handle

  -- | There was an error during the handshake negotiation.
  | Disconnected !(ConnectionId peerAddr) !(Maybe handleError)

-- | Include the outbound connection in 'ConnectionManager'.

--   This executes:
--
-- * \(Reserve\) to \(Negotiated^{*}_{Outbound}\) transitions
-- * \(PromotedToWarm^{Duplex}_{Local}\) transition
-- * \(Awake^{Duplex}_{Local}\) transition
requestOutboundConnection
  *'$\coloncolon$'* HasInitiator muxMode ~ True
  *'$\Rightarrow$'* ConnectionManager muxMode socket peerAddr handle handleError m
  *'$\rightarrow$'* peerAddr *'$\rightarrow$'* m (Connected peerAddr handle handleError)

-- | Include an inbound connection into 'ConnectionManager'.

--   This executes:
--
-- * \(Accepted\) \/ \(Overwritten\) to \(Negotiated^{*}_{Inbound}\) transitions
includeInboundConnection
  *'$\coloncolon$'* HasResponder muxMode ~ True
  *'$\Rightarrow$'* ConnectionManager muxMode socket peerAddr handle handleError m
  *'$\rightarrow$'* socket *'$\rightarrow$'* peerAddr *'$\rightarrow$'* m (Connected peerAddr handle handleError)
\end{lstlisting}

The first one asks the \connmngr{} to either connect to an outbound peer or, if
possible, reuse a duplex connection. The other one allows registering an
inbound connection, which was \texttt{accepted}. Both methods block
operations and return either an error (handshake negotiation error or
a multiplexer error) or a handle to a \textit{negotiated} connection.

Other methods which are discussed in this specification:

\begin{lstlisting}
-- | Custom Either type for the result of various methods.
data OperationResult a
    = UnsupportedState !InState
    | OperationSuccess a

-- | Enumeration of states, used for reporting; constructors elided from this
-- specification.
data InState

-- | Unregister an outbound connection.
--
--   This executes:
--
-- * \(DemotedToCold^{*}_{Local}\) transitions
unregisterOutboundConnection
  *'$\coloncolon$'* HasInitiator muxMode ~ True
  *'$\Rightarrow$'* ConnectionManager muxMode socket peerAddr handle handleError m
  *'$\rightarrow$'* peerAddr *'$\rightarrow$'* m (OperationResult ())

-- | Notify the 'ConnectionManager' that a remote end promoted us to a
-- /warm peer/.
--
-- This executes:
--
-- * \(PromotedToWarm^{Duplex}_{Remote}\) transition,
-- * \(Awake^{*}_{Remote}\) transition.
promotedToWarmRemote
  *'$\coloncolon$'* HasInitiator muxMode ~ True
  *'$\Rightarrow$'* ConnectionManager muxMode socket peerAddr handle handleError m
  *'$\rightarrow$'* peerAddr *'$\rightarrow$'* m (OperationResult InState)

-- | Notify the 'ConnectionManager' that a remote end demoted us to a /cold
-- peer/.
--
-- This executes:
--
-- * \(DemotedToCold^{*}_{Remote}\) transition.
demotedToColdRemote
  *'$\coloncolon$'* HasResponder muxMode ~ True
  *'$\Rightarrow$'* ConnectionManager muxMode socket peerAddr handle handleError m
  *'$\rightarrow$'* peerAddr -> m (OperationResult InState)

-- | Unregister outbound connection. Returns if the operation was successful.
--
-- This executes:
--
-- * \(Commit*{*}\) transition
-- * \(TimeoutExpired\) transition
unregisterInboundConnection
  *'$\coloncolon$'* HasResponder muxMode ~ True
  *'$\Rightarrow$'* ConnectionManager muxMode socket peerAddr handle handleError m
  *'$\rightarrow$'* peerAddr *'$\rightarrow$'* m (OperationResult DemotedToColdRemoteTr)

-- | Number of connections tracked by the server.
numberOfConnections
  *'$\coloncolon$'* HasResponder muxMode ~ True
  *'$\Rightarrow$'* ConnectionManager muxMode socket peerAddr handle handleError m
  *'$\rightarrow$'* STM m Int
\end{lstlisting}

\subsection{Connection states}\label{sec:connection-state}

Each connection is either initiated by \texttt{Inbound} or \texttt{Outbound} side.

\begin{lstlisting}
data Provenance
  = Inbound
  | Outbound
\end{lstlisting}
Each connection negotiates \texttt{dataFlow}:
\begin{lstlisting}
data DataFlow
  = Unidirectional
  | Duplex
\end{lstlisting}

In \texttt{Unidirectional} data flow, the connection is only used in one direction:
The outbound side runs the initiator side of mini-protocols, and the inbound side runs
responders; in \texttt{Duplex} mode, both the inbound and outbound side runs
the initiator and responder side of each mini-protocol. Negotiation of
\texttt{DataFlow} is done by the handshake protocol; the final result depends
on two factors: the negotiated version and \texttt{InitiatorOnly} flag, which is
announced through a handshake. Each connection can be in one of the following states:

\begin{lstlisting}
data ConnectionState
  -- The connection manager is about to connect with a peer.
  = ReservedOutboundState

  -- Connected to a peer, handshake negotiation is ongoing.
  | UnnegotiatedState Provenance

  -- Outbound connection, inbound idle timeout is ticking.
  | OutboundState*'$^\tau$'* DataFlow

  -- Outbound connection, inbound idle timeout expired.
  | OutboundState DataFlow

  -- Inbound connection, but not yet used.
  | InboundIdleState*'$^\tau$'* DataFlow

  -- Active inbound connection.
  | InboundState DataFlow

  -- Connection runs in duplex mode: either outbound connection negotiated
  -- 'Duplex' data flow, or 'InboundState Duplex' was reused.
  | DuplexState

  -- Connection manager is about to close (reset) the connection, before it
  -- will do that it will put the connection in 'OutboundIdleState' and start
  -- a timeout.
  | OutboundIdleState*'$^\tau$'*

  -- Connection has terminated; socket is closed, thread running the
  -- the connection is killed.  For some delay (`TIME_WAIT`) the connection is kept
  -- in this state until the kernel releases all the resources.
  | TerminatingState

  -- Connection is forgotten.
  | TerminatedState
\end{lstlisting}

The above type is a simplified version of what is implemented. The real
implementation tracks more detail, e.g. connection id (the quadruple of IP
addresses and ports), multiplexer handle, thread id, etc., which we do not need
to take care of in this specification. The rule of thumb is that all states that
have some kind of timeout should be annotated with a $\tau$. In these cases, we
are waiting for any message that would indicate a \warm{} or \hot{} transition.
If that does not happen within a timeout, we will close the connection.

In this specification, we represent \OutboundStateUniTau{}, which is not used,
the implementation avoids this constructor, for the same reasons that were given above,
regarding \texttt{InitiatorMode}.

\begin{figure}[p]
  {\begin{tikzpicture}[scale=0.66]
    \node                                     (init)                       at ( 2,   2)     {\small\InitialState};
    \node[outbound_state]                     (ReservedOutboundState)      at ( 0,-0.25)    {\small\ReservedOutboundState};
    \node[outbound_state,anchor=east]         (UnnegotiatedStateOut)       at (-1.5,  -3)   {\small\UnnegotiatedStateOut};
    \node[inbound_state]                      (UnnegotiatedStateIn)        at ( 6, -3)      {\small\UnnegotiatedStateIn};
    \node[inbound_outbound_state,anchor=west] (InboundIdleStateDup)        at ( 1, -6.0)    {\small\InboundIdleStateDup};
    \node[inbound_state,anchor=west]          (InboundIdleStateUni)        at ( 5, -8)      {\small\InboundIdleStateUni};
    \node[outbound_state,anchor=east]         (OutboundStateUni)           at (-2, -7.5)    {\small\OutboundStateUni};
    \node[inbound_outbound_state,anchor=east] (OutboundStateDupTau)        at (-1, -10.5)   {\small\OutboundStateDupTau};
    \node[inbound_outbound_state,anchor=east] (OutboundStateDup)           at (-1,  -14.0)  {\small\OutboundStateDupP};
    \node[inbound_state,anchor=west]          (InboundStateUni)            at ( 5, -16.0)   {\small\InboundStateUni};
    \node[inbound_outbound_state,anchor=west] (InboundStateDup)            at ( 1,  -13.5)  {\small\InboundStateDup};
    \node[inbound_outbound_state]             (DuplexState)                at (-1.5, -21.5) {\small\DuplexState};
    \node[inbound_outbound_state]             (OutboundIdleStateDup)       at ( 5,  -23)    {\small\OutboundIdleStateDup};
    \node[outbound_state]                     (OutboundIdleStateUni)       at (-5,  -24.5)  {\small\OutboundIdleStateUni};
    \node[inbound_outbound_state]             (TerminatingState)           at ( 3,  -27)    {\small\TerminatingState};
    \node[inbound_outbound_state]             (TerminatedState)            at ( 3,  -30)    {\small\TerminatedState};


    \draw[->] (init) -- node[fill=white,pos=0.425,above left]{\small\Reserve}                                          (ReservedOutboundState);
    \draw[->] (init) to [out=310, in=90] node[fill=white, above right]{\small\Accepted}                                (UnnegotiatedStateIn.30);

    \draw[->] (ReservedOutboundState)          -- node[fill=white,above left] {\small\Connected}                       (UnnegotiatedStateOut);
    \draw[->] (ReservedOutboundState)          -- node[fill=white,above right] {\small\Overwritten}                    (UnnegotiatedStateIn);

    \draw[->] (UnnegotiatedStateOut)           -- node[fill=white, above=18pt, left] {\small \SelfConn}               (UnnegotiatedStateIn);
    \draw[->] (UnnegotiatedStateIn)            -- node[fill=white, above=18pt, right] {\small \SelfConnRev}              (UnnegotiatedStateOut);

    \draw[->] (UnnegotiatedStateOut)           -- node[fill=white,left=-42pt] {\small\NegotiatedUniOut}                (OutboundStateUni.165);
    \draw[->] (UnnegotiatedStateOut.340)       to [out=-60, in=90]
                                               node[fill=white,right=-30pt,pos=0.23]{\small\NegotiatedDupOut}          (OutboundStateDupTau.13);

    \draw[->] (UnnegotiatedStateOut)           -- node[fill=white, right=0.3, pos=0.01]{\footnotesize\SelfNegotiatedDupIn}    (InboundIdleStateDup);
    \draw[->] (UnnegotiatedStateOut)           to [out=205, in=175]
                                               node[fill=white, pos=0.45]{\footnotesize\SelfNegotiatedUniIn}                  (InboundIdleStateUni);

    \draw[->]         (UnnegotiatedStateIn)    -- node[fill=white]{\small\NegotiatedDupIn}                  (InboundIdleStateDup.150);
    \draw[->]         (UnnegotiatedStateIn)    -- node[fill=white,pos=0.35,right=6pt]{\small\NegotiatedUniIn}        (InboundIdleStateUni.60);

    \draw[->]  (InboundIdleStateUni)           -- node[fill=white, left=6pt] {\small \SelfConnPrim}                       (OutboundStateUni);
    \draw[->]         (InboundIdleStateUni.320) to [out=-90,in=40]
                                                node[fill=white,pos=0.5,rotate=70,left=-15pt]{\small\CommitUniRem}     (TerminatingState.0);
    \draw[->, dashed] (InboundStateUni.10)      -- node[pos=0.3,fill=white,right=-45pt]{\small\DemotedToColdUniRem}    (InboundIdleStateUni.350);
    \draw[->]         (InboundIdleStateDup.195) -- node[fill=white,pos=0.6]{\small\AwakeDupLoc}                          (OutboundStateDupTau.10);

    \draw[->, dashed] (InboundIdleStateDup.200) -- node[fill=white,pos=0.65]{\small\AwakeDupRem}                       (InboundStateDup.160);
    \draw[->]         (OutboundStateDupTau.150) to [out=90,in=-170]
                                                node[fill=white,pos=0.10,left=-56pt]{\small\DemotedToColdDupLoc}       (InboundIdleStateDup.180);
    \draw[->]         (OutboundStateDup.192)    to [out=-90,in=180,looseness=2]
                                                node[fill=white,rotate=90,pos=0.2]{\small\DemotedToColdDupLoc}         (OutboundIdleStateDup.180);
    \draw[->]         (OutboundStateDupTau.192) --
                                                node[fill=white] {\small\TimeoutExpired}
                                                (OutboundStateDup.168);
    \draw[->]         (InboundStateDup)         to [out=-110,in=40]
                                                node[pos=0.9,right=20pt,rotate=70]{\footnotesize\PromotedToWarmDupLoc}     (DuplexState.10);
    \draw[->, dashed] (OutboundIdleStateDup.60) to [out=90, in=270]
                                                node[fill=white,rotate=90,pos=0.6,below=30pt]{\footnotesize\AwakeDupRem}   (InboundStateDup.345);
    \draw[->]         (DuplexState)             to [out=50,in=220]
                                                node[fill=white,pos=0.90,left=24pt,rotate=65]{\small\DemotedToColdDupLoc}  (InboundStateDup);
    \draw[->, dashed] (DuplexState.155)         to [out=90,in=-40]
                                                node[fill=white,right=10pt,pos=0.01,rotate=80]{\small\DemotedToColdDupRem} (OutboundStateDupTau);

    \draw[dashed] (OutboundStateDupTau)         -- (OutboundStateDup.south);
    \filldraw (OutboundStateDupTau.south) circle [radius=3pt];
    \filldraw (OutboundStateDup.south)    circle [radius=3pt];
    \draw[->, dashed] (OutboundStateDup)        to [out=-90,in=180]
                                                node[left,pos=0.05,left=10pt,rotate=80]{\small\PromotedToWarmDupRem}  (DuplexState);

    \draw[->]         (InboundIdleStateDup.270) to [out=-80,in=80]
                                                      node[fill=white,pos=0.5,left=-10pt,rotate=80]{\small\CommitDupRem} (TerminatingState.155);
    \draw[->, dashed] (InboundIdleStateUni.200) -- node[fill=white,right=-15pt]{\small\AwakeUniRem}                   (InboundStateUni.160);
    \draw[->, dashed] (InboundStateDup.15)      -- node[fill=white,left=-75pt,pos=0.5]{\small\DemotedToColdDupRem}    (InboundIdleStateDup.345);
    \draw[->]         (OutboundStateUni.190)    to [out=270, in=90,pos=0.23,looseness=2]
                                                node[fill=white,rotate=88,pos=0.3]{\small\DemotedToColdUniLoc}        (OutboundIdleStateUni.173);

    \draw[->]         (OutboundIdleStateUni)       to [out=300, in=180] node[fill=white,below left]{\CommitUniLoc}    (TerminatingState.180);
    \draw[->]         (OutboundIdleStateDup.280)   -- node[fill=white,pos=.4]{\CommitDupLoc}                          (TerminatingState.40);
    \draw[->]         (TerminatingState)           -- node[left]{\Terminate}                                          (TerminatedState);
  \end{tikzpicture}}
  \caption{\textit{Outbound} (blue \& violet) and \textit{inbound} (green \&
  violet) connection states and allowed transitions.}
  \label{fig:statediagram}
\end{figure}

Figure~\ref{fig:statediagram} shows all the transitions between
\texttt{ConnectionState}s. Blue and Violet states represent states of
an \textit{Outbound} connection, and Green and Violet states represent states of an
\textit{Inbound} connection. Dashed arrows indicate asynchronous
transitions that are triggered, either by a remote node or by the connection
manager itself.

Note that the vertical symmetry in the graph corresponds to the local vs remote
state of the connection, see table~\ref{table:symmetry}. The symmetry is only
broken by \InboundIdleStateAny{}, which does not have a corresponding
local equivalent. This is simply because, locally, we immediately know when we
will start initiator protocols, and the implementation is supposed to do that
promptly. This, however, cannot be assumed to be the case on the inbound side.

\begin{table}[h]
  \begin{tabular}[h]{l|l}
    \textit{local connection state} & \textit{remote connection state} \\ [0.3em]
    \hline \\
    \UnnegotiatedStateOut{}         & \UnnegotiatedStateIn{}           \\ [0.2em]
    \OutboundIdleStateAny{}         & \InboundIdleStateAny{}           \\ [0.2em]
    \OutboundStateAny{}             & \InboundStateAny{}               \\ [0.2em]
    \OutboundStateAnyTau{}          & \InboundStateAny{}               \\ [0.2em]
    \InboundStateAny{}              & \OutboundStateAny{}              \\ [0.2em]
    \DuplexState{}                  & \DuplexState{}                   \\ [0.2em]
  \end{tabular}
  \caption{Symmetry between local and remote states}
  \label{table:symmetry}
\end{table}

Another symmetry that we tried to preserve is between \texttt{Unidirectional}
and \texttt{Duplex} connections. The \texttt{Duplex} side is considerably more
complex as it includes interaction between \texttt{Inbound} and
\texttt{Outbound} connections (in the sense that inbound connections can migrate
to outbound only and vice versa). However, the state machine for an inbound-only connection is the same whether it is \texttt{Duplex} or
\texttt{Unidirectional}, see Figure~\ref{fig:statediagram-inbound-only}.
A \connmngr{} running in \texttt{ResponderMode} will use this state
machine.

For \textit{node-to-client} server, it will be even simpler, as there
we only allow for unidirectional connections. Nevertheless, this symmetry
simplifies the implementation.

\begin{figure}[p]
  {\begin{tikzpicture}[scale=0.66]
    \node                                     (init)                       at ( 2,   2)   {\small\InitialState};
    \node[inbound_outbound_state]             (ReservedOutboundState)      at ( 0,-0.25)  {\small\ReservedOutboundState};
    \node[inbound_outbound_state]             (UnnegotiatedStateIn)        at ( 5.5, -3)  {\small\UnnegotiatedStateIn};
    \node[inbound_outbound_state,anchor=west] (InboundIdleStateDup)        at ( 0, -7.0)  {\small\InboundIdleStateDup};
    \node[inbound_state,anchor=west]          (InboundIdleStateUni)        at ( 8, -7)    {\small\InboundIdleStateUni};
    \node[inbound_state,anchor=west]          (InboundStateUni)            at ( 7.5, -12) {\small\InboundStateUni};
    \node[inbound_outbound_state,anchor=west] (InboundStateDup)            at ( 0,  -12)  {\small\InboundStateDup};
    \node[inbound_outbound_state]             (TerminatingState)           at ( 6,  -16)  {\small\TerminatingState};
    \node[inbound_outbound_state]             (TerminatedState)            at ( 6,  -19)  {\small\TerminatedState};


    \draw[->] (init) -- node[fill=white,pos=0.425,above left]{\small\Reserve}                                      (ReservedOutboundState);
    \draw[->] (init) to [out=310, in=90] node[fill=white, above right]{\small\Accepted}                            (UnnegotiatedStateIn.30);

    \draw[->] (ReservedOutboundState)          -- node[fill=white,above right] {\small\Overwritten}                (UnnegotiatedStateIn);

    \draw[->]         (UnnegotiatedStateIn)  -- node[fill=white,left=-12pt]{\small\NegotiatedDupIn}                (InboundIdleStateDup.150);
    \draw[->]         (UnnegotiatedStateIn)  -- node[fill=white,pos=0.35,right=-28pt]{\small\NegotiatedUniIn}      (InboundIdleStateUni.60);
    \draw[->, dashed] (InboundIdleStateUni.347) -- node[fill=white,pos=0.35,right=-15pt]{\small\AwakeUniRem}       (InboundStateUni.15);


    \draw[->, dashed] (InboundIdleStateDup.200) -- node[fill=white,pos=0.65]{\small\AwakeDupRem}                   (InboundStateDup.160);

    \draw[->]         (InboundIdleStateDup.270) to [out=-80,in=110]
                                                      node[fill=white,pos=0.8]{\small\CommitDupRem}                (TerminatingState.170);
    \draw[->]         (InboundIdleStateUni.320) to [out=-90,in=50]
                                                      node[fill=white,pos=0.8]{\small\CommitUniRem}                (TerminatingState.10);
    \draw[->, dashed] (InboundStateDup.15)      -- node[fill=white,left=-85pt,pos=0.6]{\small\DemotedToColdDupRem} (InboundIdleStateDup.345);
    \draw[->, dashed] (InboundStateUni.165)     -- node[pos=0.3,fill=white]{\small\DemotedToColdUniRem}            (InboundIdleStateUni.200);
    % \draw[->]         (OutboundStateUni.195)    to [out=270, in=180,pos=0.23,looseness=2]
                                                      % node[right=12pt,rotate=88,pos=0.3]{\small\DemotedToColdUniLoc}  (TerminatingState.175);

\def\OutboundStateDup{\texttt{OutboundState Duplex}}
    \draw[->] (TerminatingState) -- node[fill=white]{\Terminate} (TerminatedState);
  \end{tikzpicture}}
  \caption{Sub-graph of inbound states.}
  \label{fig:statediagram-inbound-only}
\end{figure}


\subsection{Transitions}


\subsubsection{\Reserve{}}
When \connmngr{} is asked for an outbound connection, it reserves a slot
in its state for that connection.  If any other thread asks for the same
outbound connection, the \connmngr{} will raise an exception in that thread.
Reservation is done to guarantee exclusiveness for state transitions to
a single outbound thread.

\subsubsection{\Connected{}}
This transition is executed once an outbound connection successfully performs the
\texttt{connect} system call.

\subsubsection{\Accepted{} and \Overwritten{}}
Transition driven by the \texttt{accept} system call. Once it returns, the
\connmngr{} might either not know about such connection or, there might be one
in \ReservedOutboundState{}. The \Accepted{} transition represents the former
situation, while the \Overwritten{} transition captures the latter.

Let us note that if \Overwritten{} transition happened, then on the outbound
side, the scheduled \texttt{connect} call will fail. In this case, the
\ptopgov{} will recover, putting the peer in a queue of failed peers and
will either try to connect to another peer or reconnect to that peer after some
time, in which case it would re-use the accepted connection (assuming that
a duplex connection was negotiated).

\subsubsection{\NegotiatedUniOut{} and \NegotiatedDupOut{}}
Once an outbound connection has been negotiated, one of \NegotiatedUniOut{} or
\NegotiatedDupOut{} transition is performed, depending on the result of a handshake
negotiation. Duplex connections are negotiated only for node-to-node protocol
versions higher than \texttt{NodeToNodeV\_7}\todoimpl{the exact version number
might change}, and neither side declared that it is an \emph{initiator} only.

If a duplex outbound connection was negotiated, the \connmngr{} needs to ask the
\inbgov{} to start and monitor responder mini-protocols on the outbound
connection.

\begin{detail}
This transition is done by the \texttt{requestOutboundConnection}.
\end{detail}


\subsubsection{\NegotiatedUniIn{} and \NegotiatedDupIn{}}
This transition is performed once the handshake negotiated an unidirectional or
duplex connection on an inbound connection.

For \NegotiatedUniIn{}, \NegotiatedDupIn{}, \NegotiatedDupOut{}
transitions, the \textit{inbound protocol governor} will restart all responder
mini-protocols (for all \established{}, \warm{} and \hot{} groups of
mini-protocols) and keep monitoring them.

\begin{detail}
This transition is done by the \texttt{includeInboundConnection}.
\end{detail}

\begin{detail}
  Whenever a mini-protocol terminates, it is immediately restarted using
  an on-demand strategy. All \textit{node-to-node} protocols have initial agency
  on the client side; hence, restarting them on-demand does not send any
  message.
\end{detail}


\subsubsection{\AwakeDupLoc{}, \AwakeDupRem{} and \AwakeUniRem{}}
All the awake transitions start either at \InboundIdleStateAny{}, the
\AwakeDupRem{} can also be triggered on \OutboundIdleStateDup{}.

\begin{detail}
  \AwakeDupLoc{} transition is done by \texttt{requestOutboundConnection} on
  the request of \ptopgov{}, while \AwakeDupRem{} and \AwakeUniRem{} are
  triggered by incoming traffic on any of the responder mini-protocols (asynchronously if
  detected any \warm{}/\hot{} transition).
\end{detail}


\subsubsection{\CommitUniRem{}, \CommitDupRem{}}\label{sec:tr_commit}
Both commit transitions happen after \textit{protocol idle timeout} of
inactivity (as the \TimeoutExpired{} transition does). They transition to
\TerminatingState{} (closing the bearer). For duplex connections, a normal
shutdown procedure goes through \InboundIdleStateDup{}
via \CommitDupRem{} - which gave the name to this transition.

The inactivity of responder mini-protocols triggers these transitions. They
both protect against a client that connects but never sends any data through
the bearer; also, as part of a termination sequence, it is protecting us from
shutting down a connection which is transitioning between \warm{} and \hot{}
states.

Both commit transitions:
\begin{itemize}
  \item \CommitDupRem{}
  \item \CommitUniRem{}
\end{itemize}
need to detect idleness during a time interval (which we call: \text{protocol
idle timeout}). If, during this time frame, inbound traffic on any responder
mini-protocol is detected, one of the \AwakeDupRem{} or \AwakeUniRem{}
transition is performed. The idleness detection might also be interrupted by
the local \AwakeDupLoc{} transition.

\begin{detail}
  These transitions can be triggered by \texttt{unregisterInboundConnection} and
  \texttt{unregisterOutboundConnection} (both are non-blocking), but the
  stateful idleness detection during \textit{protocol idle timeout} is
  implemented by the server.

  The implementation relies on two properties:
  \begin{itemize}
    \item the multiplexer being able to start mini-protocols on-demand, which
      allows us to restart a mini-protocol as soon as it returns without
      disturbing idleness detection;
    \item the initial agency for any mini-protocol is on the client.
  \end{itemize}
\end{detail}

\begin{detail}
  Whenever an outbound connection is requested, we notify the server about
  a new connection.  We also do that when the connection manager hands over an
  existing connection.  If \inbgov{} is already tracking that connection,
  we need to make sure that
  \begin{itemize}
    \item \inbgov{} preserves its internal state of that connection;
    \item \inbgov{} does not start mini-protocols, as they are already running
      (we restart responders as soon as they stop, using the on-demand
      strategy).
  \end{itemize}
\end{detail}


\subsubsection{\DemotedToColdUniLoc{}, \DemotedToColdDupLoc{}}
This transition is driven by the \ptopgov{} when it decides to demote the peer
to \cold{} state; its domain is \OutboundStateAny{} or \OutboundStateDupTau{}.
The target state is \OutboundIdleStateAny{} in which the connection manager
sets up a timeout.  When the timeout expires, the connection manager will do
\CommitAnyLoc{} transition, which will reset the connection.

\begin{detail}
This transition is done by \texttt{unregisterOutboundConnection}.
\end{detail}


\subsubsection{\DemotedToColdUniRem{}, \DemotedToColdDupRem{}}
Both transitions are edge-triggered, the connection manager is notified by the
\inbgov{} once it notices that all responders became idle. Detection of
idleness during \textit{protocol idle timeout} is done in a separate step which
is triggered immediately, see section~\ref{sec:tr_commit_rem} for details.

\begin{detail}
  Both transitions are done by \texttt{demotedToColdRemote}.
\end{detail}


\subsubsection{\PromotedToWarmDupLoc{}}
This transition is driven by the local \ptopgov{} when it promotes a \cold{} peer
to \warm{} state. \connmngr{} will provide a handle to an existing connection, so that
\ptopgov{} can drive its state.

\begin{detail}
This transition is done by \texttt{requestOutboundConnection}.
\end{detail}


\subsubsection{\TimeoutExpired{}}
This transition is triggered when the protocol idleness timeout expires while
the connection is in \OutboundStateDupTau{}. The server starts this timeout
when it triggers \DemotedToColdAnyRem{} transition. The connection manager
tracks the state of this timeout so we can decide if a connection in the outbound
state can terminate or if it needs to wait for that timeout to expire.

\begin{detail}
  This transition is done by \texttt{unregisterInboundConnection}.
\end{detail}


\subsubsection{\PromotedToWarmDupRem{}}
The remote peer triggers this asynchronous transition.  The \inbgov{}
can notice it by observing the multiplexer ingress side of running mini-protocols.
It then should notify the \connmngr{}.

\begin{detail}
  This transition is done by \texttt{promotedToWarmRemote}.

  The implementation relies on two properties:
  \begin{itemize}
    \item all initial states of node-to-node mini-protocols have client agency, i.e. the
      the server expects an initial message;
    \item all mini-protocols are started using an on-demand strategy, which allows
      to detect when a mini-protocol is brought to life by the multiplexer.
  \end{itemize}
\end{detail}


\subsubsection{\Prune{} transitions}
First, let us note that a connection in \InboundStateDup{} could have been
initiated by either side (Outbound or Inbound). This means that even though a node might not have
accepted any connection, it could end up serving peers and possibly go beyond
server hard limit, thus exceeding the number of allowed file descriptors. This is
possible via the following path:

\begin{itemize}
  \item[] \Connected{},
  \item[] \NegotiatedDupOut{},
  \item[] \PromotedToWarmDupRem{},
  \item[] \DemotedToColdDupLoc{}
\end{itemize}

which leads from the initial state \InitialState{} to \InboundStateDup{}, the
same state in which accepted duplex connections end up. Even though the server
rate limits connections based on how many connections are in this state, we
could exceed the server hard limit.

These are all transitions that potentially could lead to exceeding the server hard limit,
all of them are transitions from some outbound/duplex state into an inbound/duplex state:
\begin{itemize}
  \item \DuplexState{} to \InboundStateDup{} (via \DemotedToColdDupLoc{})
  \item \OutboundStateDupTau{} to \InboundStateDup{} (via \DemotedToColdDupLoc{})
  \item \OutboundIdleStateDup{} to \InboundStateDup{} (via \AwakeDupRem{})
  \item \OutboundStateDupTau{} to \DuplexState{} (via \PromotedToWarmDupRem{})
  \item \OutboundStateDup{} to \DuplexState{} (via \PromotedToWarmDupRem{})
\end{itemize}

To solve this problem, the connection manager will check
to see if the server hard limit was exceeded in any of the above transitions. If that happens, the \connmngr{} will reset an
arbitrary connection (with some preference).

The reason why going from \OutboundStateDupTau{} (or \OutboundStateDup{}, or
\OutboundIdleStateDup{}) to \InboundStateDup{} might exceed the server hard limit
is exacty the same as the \DuplexState{} to \InboundStateDup{} one.
However, the reason why going from \OutboundStateDupTau{} to \DuplexState{} might
exceed the limit is more tricky.  To reach a \DuplexState{}, one assumes there must
have been an incoming \textit{accepted} connection. However, there's another way that two
end-points can establish a connection without a node accepting it. If two nodes try
to request an outbound connection simultaneously, it is possible for two applications
to both perform an active opening to each other at the same time.  This is called a
\href{https://flylib.com/books/en/3.223.1.190/1/}{\textit{simultaneous open}}.
In a simultaneous TCP open, we can have $2$ nodes establishing a connection without any of
them having explicitly accepted a connection, which can make a server violate its file
descriptor limit.

Given this, we prefer to reset an inbound connection rather than close an outbound
connection because, from a systemic point of view, outbound connections are more
valuable than inbound ones. If we keep the number of \established{} peers to
be smaller than the server hard limit; with the right policy, we should never need
to reset a connection in \DuplexState{}. However, when dealing with a connection that
transitions from \OutboundStateDupTau{} to \DuplexState{}, we actually need to
make sure this connection is closed, because we have no way to know for sure
if this connection is the result of a TCP simultaneous open there might
not be any other connection available to prune that can make space for this one.

The \textit{inbound protocol governor} is in a position to make an educated
decision about which connection to reset. Initially, we aim for a decision driven by
randomness, but other choices are possible\footnote{We can take into account
whether we are \hot{} to the remote end, or for how long we have been \hot{} to
to the remote node.} and the implementation should allow to easily extend the
initial choice.


\subsubsection{\CommitUniRem{}, \CommitDupRem{}}\label{sec:tr_commit_rem}
Both commit transitions happen after \textit{protocol idle timeout} of
inactivity (as the \TimeoutExpired{} transition does). They transition to
\TerminatingState{} (closing the bearer). For duplex connections, a normal
shutdown procedure goes through \InboundIdleStateDup{}
via \CommitDupRem{} - which gave the name to this transition, or through
\OutboundIdleStateDup{} via \CommitDupLoc{} transition.

These transitions are triggered by the inactivity of responder mini-protocols. They
both protect against a client that connects but never sends any data through
the bearer; also, as part of a termination sequence, it is protecting us from
shutting down a connection which is transitioning between \warm{} and \hot{}
states.

Both commit transitions:
\begin{itemize}
  \item \CommitDupRem{}
  \item \CommitUniRem{}
\end{itemize}

Need to detect idleness during time interval (which we call: \text{protocol
idle timeout}). If during this time frame, inbound traffic on any responder
mini-protocol is detected, one of the \AwakeDupRem{} or \AwakeUniRem{}
transition is performed. The local \AwakeDupLoc{} transition might also interrupt the idleness detection.

\begin{detail}
  These transitions can be triggered by \texttt{unregisterInboundConnection} and
  \texttt{unregisterOutboundConnection} (both are non-blocking), but the
  stateful idleness detection during \textit{protocol idle timeout} is
  implemented by the \inbgov{}.  The implementation relies on two
  properties:
  \begin{itemize}
    \item the multiplexer being able to start mini-protocols on-demand, which
      allows us to restart a mini-protocol as soon as it returns without
      disturbing idleness detection;
    \item the initial agency for any mini-protocol is on the client.
  \end{itemize}
\end{detail}

\begin{detail}
  Whenever an outbound connection is requested, we notify the server about
  a new connection.  We also do that when the connection manager hands over an
  existing connection.  If \inbgov{} is already tracking that connection,
  we need to make sure that
  \begin{itemize}
    \item \inbgov{} preserves its internal state of that connection;
    \item \inbgov{} does not start mini-protocols, as they are already running
      (we restart responders as soon as they stop, using the on-demand
      strategy).
  \end{itemize}
\end{detail}


\subsubsection{\CommitUniLoc{}, \CommitDupLoc{}}\label{sec:tr_commit_loc}
As previous two transitions, these also are triggered after \textit{protocol idle
timeout}, but this time, they are triggered on the outbound side.  This transition
will reset the connection, and the timeout ensures that the remote end can clear its ingress queue before the \TCP{} reset arrives.  For a more
detailed analysis, see~\ref{sec:connection-close} section.


\subsubsection{\Terminate{}}
After a connection is closed, we keep it in \TerminatingState{} for the
duration of \textit{wait time timeout}.  When the timeout expires, the
connection is forgotten.  \todo[inline]{Add a haddock link to \texttt{daTimeWaitTimeout}}

\subsubsection{Connecting to oneself}
The transitions described in this section can only happen when the connection
the manager was requested to connect to its own listening socket and the address
wasn't translated by the \textsf{OS} or a \textsf{NAT}.  This could happen only
in particular situations:

\begin{enumerate}
  \item misconfiguration a system;
  \item running a node on multiple interfaces;
  \item in some cases, it could also happen when learning about oneself from the
    ledger;
  \item or due to peer sharing.
\end{enumerate}

In some of these cases, the external IP address would need to agree with the
internal one, which is true for some cloud service providers.

Let us note that these connections effectively only add delay, and thus they
will be replaced by the outbound governor (by its churn mechanism).

These transitions are not indicated in the figure~\ref{fig:statediagram},
instead they are shown bellow in figure~\ref{fig:statediagram-selfconn}.

\paragraph{\SelfConn{} and \SelfConnRev{}}
We allow transitioning between
\begin{itemize}
  \item\UnnegotiatedStateOut{} and
  \item\UnnegotiatedStateIn{}
\end{itemize}
or the other way.  This transition is not guaranteed as on some systems in
such case, the outbound and inbound addresses (as returned by the
\texttt{accept} call) can be different.  Whether \SelfConn{} or \SelfConnRev{}
will happen depending on the race between the inbound and outbound sides.

\paragraph{\SelfConnPrim{} and \SelfConnPrimRev{}}
We also allow transitioning between
\begin{itemize}
  \item\InboundIdleStateAny{} and
  \item\OutboundStateAny{}
\end{itemize}

After the handshake is negotiated, there is a race between inbound and outbound
threads, which need to be resolved consistently.

\begin{figure}[p]
  {\begin{tikzpicture}[scale=0.66]
    \node                                     (init)                       at ( 2,   2)     {\small\InitialState};
    \node[outbound_state]                     (ReservedOutboundState)      at ( 0,-0.25)    {\small\ReservedOutboundState};
    \node[outbound_state,anchor=east]         (UnnegotiatedStateOut)       at (-1,  -3)     {\small\UnnegotiatedStateOut};
    \node[inbound_state]                      (UnnegotiatedStateIn)        at ( 5.5, -3)    {\small\UnnegotiatedStateIn};
    \node[inbound_outbound_state,anchor=west] (InboundIdleStateDup)        at ( 5, -10.5)   {\small\InboundIdleStateDup};
    \node[inbound_state,anchor=west]          (InboundIdleStateUni)        at ( 5, -7.5)    {\small\InboundIdleStateUni};
    \node[outbound_state,anchor=east]         (OutboundStateUni)           at (-2, -7.5)    {\small\OutboundStateUni};
    \node[inbound_outbound_state,anchor=east] (OutboundStateDupTau)        at (-2, -10.5)   {\small\OutboundStateDupTau};

    \draw[->] (init) -- node[fill=white,pos=0.425,above left]{\small\Reserve}                                          (ReservedOutboundState);
    \draw[->] (init) to [out=310, in=90] node[fill=white, above right]{\small\Accepted}                                (UnnegotiatedStateIn.30);

    \draw[->] (ReservedOutboundState)          -- node[fill=white,above left] {\small\Connected}                       (UnnegotiatedStateOut);
    \draw[->] (ReservedOutboundState)          -- node[fill=white,above right] {\small\Overwritten}                    (UnnegotiatedStateIn);

    \draw[->] (UnnegotiatedStateOut)           -- node[fill=white,left=-42pt] {\small\NegotiatedUniOut}                (OutboundStateUni.165);
    \draw[->] (UnnegotiatedStateOut.340)       to [out=-60, in=90]
                                               node[fill=white,right=-20pt,pos=0.23]{\small\NegotiatedDupOut}          (OutboundStateDupTau.13);

    \draw[->]         (UnnegotiatedStateIn)    -- node[fill=white,left=-40pt,pos=0.33]{\small\NegotiatedDupIn}         (InboundIdleStateDup.150);
    \draw[->]         (UnnegotiatedStateIn)    -- node[fill=white,pos=0.35,right=-20pt]{\small\NegotiatedUniIn}        (InboundIdleStateUni.60);

    \draw[->]         (UnnegotiatedStateOut.3)   -- node[above]{\small\SelfConn}                                       (UnnegotiatedStateIn.177);
    \draw[->]         (UnnegotiatedStateIn.183)  -- node[below]{\small\SelfConnRev}                                    (UnnegotiatedStateOut.357);

    \draw[->]        (OutboundStateUni.3)        -- node[above]{\small\SelfConnPrim}                                   (InboundIdleStateUni.177);
    \draw[->]        (InboundIdleStateUni.183)   -- node[below]{\small\SelfConnPrimRev}                                (OutboundStateUni.357);

    \draw[->]        (OutboundStateDupTau.3)     -- node[above]{\small\SelfConnPrim}                                   (InboundIdleStateDup.177);
    \draw[->]        (InboundIdleStateDup.183)   -- node[below]{\small\SelfConnPrimRev}                                (OutboundStateDupTau.357);
  \end{tikzpicture}}
  \caption{Extra transitions when connecting to onself}
  \label{fig:statediagram-selfconn}
\end{figure}

\subsection{Protocol errors}
If a mini-protocol errors, on either side, the connection will be reset and put in
\TerminatedState{}. This can happen in any connection state.


\subsection{Closing connection}\label{sec:connection-close}

By default, when the operating system is closing a socket, it is done in the
background, but when \texttt{SO\_LINGER} option is set, the \texttt{close}
system call blocks until either all messages are sent or the specified linger
timeout fires. Unfortunately, our experiments showed that if the remote side
(not the one that called \texttt{close}), delays reading the packets, then even
with \texttt{SO\_LINGER} option set, the socket is kept in the background by
the OS.  On \texttt{FreeBSD} it is eventually closed cleanly, on \texttt{Linux}
and \texttt{OSX} it is reset. This behaviour gives the remote end the power to keep resources for an extended amount of time, which we want to
avoid. We thus decided to always use \texttt{SO\_LINGER} option with timeout
set to \texttt{0}, which always resets the connection (i.e. it sets the
\texttt{RST} \TCP{} flag). This has the following consequences:

\begin{itemize}
  \item Four-way handshake used by \TCP{} termination will not be used. The
    four-way handshake allows one to close each side of the connection separately.
    With the reset, the OS is instructed to forget the state of the connection
    immediately (including freeing unread ingress buffer).
  \item the system will not keep the socket in \texttt{TIME\_WAIT} state, which
    was designed to:
    \begin{itemize}
      \item provide enough time for final \texttt{ACK} to be received;
      \item protect the connection from packets that arrive late. Such
        packets could interfere with a new connection
        (see~\cite{stevens2003unix}).
    \end{itemize}
\end{itemize}

The connection state machine makes sure that we close a connection only when
both sides are not using the connection for some time: for outbound connections
this is configured by the timeout on the \OutboundIdleStateAny{}, while for
inbound connections by the timeout on the \InboundIdleStateAny{}.
\todo{Add haddock link to \texttt{daProtocolIdleTimeout}}
This ensures that the application can read from ingress buffers
before the \texttt{RST} packet arrives.  Excluding protocol errors and prune
transitions, which uncooperatively reset the connection.

We also provide application-level \texttt{TIME\_WAIT} state:
\TerminatingState{}, in which we keep a connection, which should also protect us
from late packets from a previous connection. However, the connection manager
does allow to accept new connections during \TerminatingState{} - it is
the client's responsibility not to reconnect too early. For example,
\ptopgov{} enforces a 60s idle period before it can reconnect to the same peer, after
either a protocol error or a connection failure.

From an operational point of view, it's essential that connections are not held in
\texttt{TIME\_WAIT} state for too long. This would be problematic when
restarting a node (without rebooting the system) (e.g. when adjusting
configuration). Since we reset connections, this is not a concern.


\subsection{\textit{Outbound} connection}

If the connection state is in either \ReservedOutboundState{},
\UnnegotiatedStateIn{} or \InboundStateDup{} then, when calling
\texttt{requestOutboundConnection} the state of a connection leads to either
\OutboundStateUni{} or \DuplexState{}.

If \texttt{Unidirectional} connection was
negotiated, \texttt{requestOutboundConnection} must error. If \texttt{Duplex}
connection was negotiated, it can use the egress side of this connection leading
to \DuplexState{}.

\paragraph{\textnormal{initial state (\InitialState{})}:} the \connmngr{} does not have
  a connection with that peer. The connection is put in \ReservedOutboundState{}
  before \connmngr{} connects to that peer;

\paragraph{\UnnegotiatedStateIn{}:} if the \connmngr{} accepted
  a connection from that peer, handshake is ongoing;
  \texttt{requestOutboundConnection} will await until the connection state
  changes to \InboundStateAny{}.

\paragraph{\InboundStateUni{}:} if \texttt{requestOutboundConnection} finds
a connection in this state it will error.

\paragraph{\InboundStateDup{}:} if \connmngr{} accepted connection from
  that peer and handshake negotiated a \texttt{Duplex} data flow;
  \texttt{requestOutboundConnection} transitions to \DuplexState{}.

\paragraph{\TerminatingState{}:} block until \TerminatedState{} and start from
the initial state.

\paragraph{\textnormal{Otherwise}:} if \connmngr{} is asked to connect to
peer, and there exists a connection in any other state, e.g.
\UnnegotiatedStateOut{}, \OutboundStateAny{}, \DuplexState{}, \connmngr{} signals the caller with an error, see
section~\ref{table:requestOutboundConnection}.

Figure~\ref{fig:outbound_flow} shows outbound connection state evolution,  e.g.
the flow graph of \texttt{requestOutboundConnection}.

\begin{figure}[p]
  \footnotesize{\begin{tikzpicture}[scale=0.8]
    \node[decision]               (init)      at (0,0) {Has a connection to that peer?};
    \node[inbound_outbound_state] (not_found) at (-5, 0) {\ReservedOutboundState{}};

    % Connection not found flow
    \draw[->] (init) -- node[above] {\textbf{no}}  (not_found);
    \node[outbound_state] (connected) at (-5, -3) {\UnnegotiatedStateOut{}};
    \draw[->] (not_found) -- node[left] {\textbf{\texttt{connect}}} (connected);

    % This may be influenced by the `initiator only` flag or version of the connection.
    \node[decision]               (handshake_decision_outbound) at (-5, -6.5) {Which data flow was negotiated?};
    \node[outbound_state]         (outbound_unidf)              at (-8.5, -9)   {\OutboundStateUni{}};
    \draw (connected) -- node[left] {\textbf{\textbf{handshake}}} (handshake_decision_outbound);

    \node[inbound_outbound_state] (outbound_dupdf)             at (-8, -11)  {\OutboundStateDup{}};
    \draw[->] (handshake_decision_outbound.west) -| node[left, near end] {\textbf{\texttt{Unidirectional}}} (outbound_unidf);
    \draw[->] (handshake_decision_outbound) |- node[right, near start] {\textbf{\texttt{Duplex}}} (outbound_dupdf);

    % Connection found flow

    \node[decision] (found) at (0, -5)     {What is the current state?};
    \draw (init) -- node[right] {\textbf{yes}} (found);

    \node[inbound_outbound_state,anchor=west] (reserved_outbound) at (1, -8)  {\ReservedOutboundState};
    \node[circle,fill=black] (x0) at (0, -8) {};
    \node[error,anchor=west]                  (termination_c)     at (4, -9) {\textbf{error \texttt{ConnectionExists}}};
    \draw (x0) |- (reserved_outbound);
    \draw[] (reserved_outbound) |- (termination_c);

    \node[inbound_outbound_state,anchor=west] (unnegotiated_inbound) at (1, -10) {\UnnegotiatedStateIn};
    \node[circle,fill=black] (x1) at (0, -10) {};
    \draw (x1) |- (unnegotiated_inbound);
    \draw[->] (unnegotiated_inbound) to[out=90,in=0] node[above right] {\textbf{await for handshake}} (found.east);

    \node[inbound_state,anchor=west] (inbound_unidf) at (1, -11) {\InboundStateUni};
    \node[circle,fill=black] (x2) at (0, -11) {};
    \node[error,anchor=west] (termination_unidf) at (4, -12) {\textbf{error \texttt{ForbiddenConnection}}};
    \draw (x2) |- (inbound_unidf);
    \draw[] (inbound_unidf.200) |- (termination_unidf);

    \node[inbound_state,anchor=west] (inboundidle_unidf)       at (1, -13) {\InboundIdleStateUni};
    \node[circle,fill=black] (x3) at (0, -13) {};
    \node[error,anchor=west] (termination_inboundidle) at (4, -14) {\textbf{error \texttt{ForbiddenConnection}}};
    \draw (x3) |- (inboundidle_unidf);
    \draw (inboundidle_unidf.200) |- (termination_inboundidle);

    \node[inbound_outbound_state,anchor=west] (inboundidle_dupdf)         at (1, -15) {\InboundIdleStateDup};
    \node[circle,fill=black] (x4) at (0, -15) {};
    \node[inbound_outbound_state,anchor=west] (outbound_dupdf_2) at (4, -16) {\OutboundStateDup};
    \draw (x4) |- (inboundidle_dupdf);
    \draw (inboundidle_dupdf.225) |- (outbound_dupdf_2);

    \node[inbound_outbound_state,anchor=west] (inbound_dupdf) at (1, -17) {\InboundStateDup};
    \node[circle,fill=black] (x5) at (0, -17) {};
    \node[inbound_outbound_state,anchor=west] (duplex)        at (4, -18) {\DuplexState};
    \draw (x5) |- (inbound_dupdf);
    \draw (inbound_dupdf) |- (duplex);

    \node[impossible_outbound_state,anchor=west] (outbound_uni) at (1, -19) {\OutboundStateUni};
    \node[circle,fill=black] (x6) at (0, -19) {};
    \node[error,anchor=west] (termination_outuni) at (4, -20) {\textbf{error \texttt{ConnectionExists}}};
    \draw (x6) |- (outbound_uni);
    \draw (outbound_uni.200) |- (termination_outuni.west);

    \node[impossible_outbound_state,anchor=west] (duplex_imp)   at (1, -21) {\DuplexState};
    \node[circle,fill=black] (x7) at (0, -21) {};
    \node[error,anchor=west] (termination_dupuni) at (4, -22) {\textbf{error \texttt{ConnectionExists}}};
    \draw (x7) |- (duplex_imp);
    \draw (duplex_imp) |- (termination_dupuni.west);

    \node[inbound_outbound_state,anchor=west] (outboundidle) at (1, -23) {\OutboundIdleStateAny};
    \node[circle,fill=black] (x8) at (0,-23) {};
    \node[error,anchor=west] (termination_outboundidle) at (4,-24) {\textbf{error \texttt{ForbiddenOperation}}};
    \draw (x8) |- (outboundidle);
    \draw (outboundidle.200) |- (termination_outboundidle);

    \node[inbound_outbound_state,anchor=west] (terminating) at (1, -25) {\TerminatingState};
    \node[circle,fill=black] (x9) at (0, -25) {};
    \draw (x9) |- (terminating);
    \draw[->] (terminating.0) to [out=30,in=340] node[above right,pos=0.8,looseness=2] {\textbf{await wait time timeout}} (init.east);

    \node[inbound_outbound_state,anchor=west] (terminated)  at (1, -26) {\TerminatedState};
    \node[circle,fill=black] (x10) at (0, -26) {};
    \draw (x10) |- (terminated);
    \draw[->] (terminated) to [out=90,in=315] (not_found);

    \draw (found.south) |- (x10);

  \end{tikzpicture}}
  \caption{\textit{Outbound} connection flow graph}
  \label{fig:outbound_flow}
\end{figure}

\subsubsection{\OutboundStateDup{} and \DuplexState{}}
Once an outbound connection negotiates \texttt{Duplex} data flow, it transfers
to \OutboundStateDup{}.  At this point, we need to start responder protocols.
This means that the \connmngr{} needs a way to inform the server (which
accepts and monitors inbound connections) to start the protocols and monitor
that connection.  This connection will transition to \DuplexState{} only once
we notice incoming traffic on any of \established{} protocols. Since this connection might
have been established via TCP simultaneous open, this transition to \DuplexState{} can
also trigger \Prune{} transitions if the number of inbound connections becomes above
the limit.

\begin{detail}
  The implementation is using a \texttt{TBQueue}. The server uses this channel
  for incoming duplex outbound and inbound connections.
\end{detail}

\subsubsection{Termination}\label{sec:outbound_termination}

When \ptopgov{} demotes a peer to \cold{} state, an outbound
the connection needs to transition from either:

\begin{itemize}
  \item \OutboundStateAny{} to \OutboundIdleStateAny{}
  \item \OutboundStateDupTau{} to \InboundIdleStateDup{}
  \item \DuplexState{} to \InboundStateDup{}
\end{itemize}

To support that the \connmngr{} exposes a method:

\begin{lstlisting}
unregisterOutboundConnection *'$\coloncolon$'* peerAddr *'$\rightarrow$'* m ()
\end{lstlisting}
This method performs \DemotedToColdUniLoc{} or
\DemotedToColdDupLoc{} transition. In the former case, it will shut down the
multiplexer and close the \TCP{} connection; in the latter case, besides
changing the connection state, it will also trigger \Prune{} transitions if
the number of inbound connections is above the limit.

\subsubsection{Connection manager methods}

The tables~\ref{table:requestOutboundConnection}
and~\ref{table:unregisterOutboundConnection} show transitions performed by
\begin{itemize}
  \item \texttt{requestOutboundConnection} and
  \item \texttt{unregisterOutboundConnection}
\end{itemize}
respectively.

\begin{table}
  \begin{tabular}[h]{ll}
    \textit{State}           & \textit{Action} \\\hline\\[2pt]
    \InitialState{}          &
      \begin{minipage}[t]{8cm}
        \begin{itemize}
          \item \ReservedOutboundState{},
          \item \Connected{},
          \item start connection thread (handshake, \mux{})
          \item \NegotiatedUniOut{} or \NegotiatedDupOut{}
        \end{itemize}
      \end{minipage}
      \vspace{8pt}\\
    \ReservedOutboundState{} & error \texttt{ConnectionExists} \\[8pt]
    \UnnegotiatedStateOut{}  & error \texttt{ConnectionExists} \\[8pt]
    \UnnegotiatedStateIn{  } &
      \begin{minipage}[t]{7cm}
        await for \InboundStateAny{}, if negotiated duplex connection
        transition to \DuplexState{}, otherwise error
        \texttt{ForbiddenConnection}
      \end{minipage}
      \vspace{8pt}\\
    \OutboundStateAny{}      & error \texttt{ConnectionExists}    \\[8pt]
    \OutboundStateDupTau{}   & error \texttt{ConnectionExists}    \\[8pt]
    \OutboundIdleStateAny{}  & error \texttt{ForbiddenOperation}  \\[8pt]
    \InboundIdleStateUni{}   & error \texttt{ForbiddenConnection} \\[8pt]
    \InboundIdleStateDup{}   & transition to \OutboundStateDup{}  \\[8pt]
    \InboundStateUni{}       & error \texttt{ForbiddenConnection} \\[8pt]
    \InboundStateDup{}       & transition to \DuplexState{}       \\[8pt]
    \DuplexState{}           & error \texttt{ConnectionExists}    \\[8pt]
    \TerminatingState{}      & await for \TerminatedState{}       \\[8pt]
    \TerminatedState{}       & can be treated as initial state    \\[8pt]
  \end{tabular}
  \caption{\texttt{requestOutboundConnection}; states indicated with a \textsuperscript{$\dagger$} are forbidden by \TCP{}.}
  \label{table:requestOutboundConnection}
\end{table}

\begin{table}
  \begin{tabular}[h]{ll}
    \textit{State}           & \textit{Action} \\\hline\\[2pt]
    \InitialState{}          & \texttt{no-op} \\[8pt]
    \ReservedOutboundState{} & error \texttt{ForbiddenOperation} \\[8pt]
    \UnnegotiatedStateOut{}  & error \texttt{ForbiddenOperation} \\[8pt]
    \UnnegotiatedStateIn{}   & error \texttt{ForbiddenOperation} \\[8pt]
    \OutboundStateAny{}      & \DemotedToColdAnyLoc{} \\[8pt]
    \OutboundStateDupTau{}   & \Prune{} or \DemotedToColdDupLoc{} \\[8pt]
    \OutboundIdleStateAny{}  & \texttt{no-op} \\[8pt]
    \InboundIdleStateUni{}   & assertion error \\[8pt]
    \InboundIdleStateDup{}   & \texttt{no-op} \\[8pt]
    \InboundStateUni{}       & assertion error \\[8pt]
    \InboundStateDup{}       & \texttt{no-op} \\[8pt]
    \DuplexState{}           & \Prune{} or \DemotedToColdDupLoc{} \\[8pt]
    \TerminatingState{}      & \texttt{no-op} \\[8pt]
    \TerminatedState{}       & \texttt{no-op} \\[8pt]
  \end{tabular}
  \caption{\texttt{unregisterOutboundConnection}}
  \label{table:unregisterOutboundConnection}
\end{table}

The choice between \texttt{no-op} and error is solved by the following rule: if
the calling component (e.g. \ptopgov{}), can keep its state in
a consistent state with \connmngr{} then use \texttt{no-op}, otherwise
error.  Since both \inbgov{} and \ptopgov{} are using \mux{} to track the state
of the connection, the state can't be inconsistent.

\subsection{\textit{Inbound} connection}
Initial states for inbound connection are either:
\begin{itemize}
  \item initial state \InitialState{};
  \item \ReservedOutboundState{}:
    this can happen when \texttt{requestOutboundConnection}
    reserves a connection with \ReservedOutboundState{}, but before it calls
    \texttt{connect} the \texttt{accept} call returned.  In this case, the
    \texttt{connect} call will fail and, as a consequence,
    \texttt{requestOutboundConnection} will fail too. Any mutable variables
    used by it can be disposed since no thread can be blocked
    on it: if another thread asked for an outbound connection
    with that peer, it would see \ReservedOutboundState{} and throw
    \texttt{ConnectionExists} exception.

    To make sure that this case is uncommon, we need to guarantee that the
    \connmngr{} does not block between putting the connection in the
    \ReservedOutboundState{} and calling the \texttt{connect} system call.
\end{itemize}

\begin{figure}[h]
  \footnotesize{\begin{tikzpicture}[scale=0.8]
    \node (init) at (2, 0) {\small\InitialState};
    \node[inbound_outbound_state,draw] (reserved_outbound)    at (-4, 0) {\ReservedOutboundState};
    \node[inbound_outbound_state,draw] (unnegotiated_inbound) at (0, -2) {\UnnegotiatedStateIn};
    \draw[->] (init)              -- (unnegotiated_inbound);
    \draw[->] (reserved_outbound) -- (unnegotiated_inbound);

    \node[decision] (handshake_decision_inbound) at (0, -5) {Which data flow was negotiated?};
    \draw (unnegotiated_inbound) -- (handshake_decision_inbound);
    \node[inbound_state]          (inbound_unidf) at (-3, -8) {\InboundStateUni{}};
    \node[inbound_outbound_state] (inbound_dupdf) at (3,  -8) {\InboundStateDup{}};
    \draw[->] (handshake_decision_inbound.west) -| node[left, near end]{\textbf{\texttt{Unidirectional}}} (inbound_unidf);
    \draw[->] (handshake_decision_inbound.east) -| node[right,near end]{\textbf{\texttt{Duplex}}}         (inbound_dupdf);

    \node[inbound_outbound_state] (duplex) at (3, -11) {\DuplexState{}};
    \draw[->] (inbound_dupdf) -- node[right]{\textbf{\texttt{requestOutboundConnection}}} (duplex);
  \end{tikzpicture}}
  \caption{\textit{Inbound} connection flow graph, where both bordered states:
  \ReservedOutboundState{} and \UnnegotiatedStateIn{} are initial states.}
\end{figure}

\subsubsection{Connection manager methods}

The following tables show transitions of the following connection manager methods:
\begin{itemize}
  \item \texttt{includeInboundConnection}: table~\ref{table:includeInboundConnection}
  \item \texttt{promotedToWarmRemote}: table~\ref{table:promotedToWarmRemote}
  \item \texttt{demotedToColdRemote}: table~\ref{table:demotedToColdRemote}
  \item \texttt{unregisterInboundConnection}: table~\ref{table:unregisterInboundConnection}
\end{itemize}

States indicated by `-` are preserved, though unexpected;
\texttt{promotedToWarmRemote} will use \texttt{UnsupportedState ::
OperationResult a} to indicate that to the caller.

\begin{table}
  \begin{tabular}[h]{ll}
    \textit{State}           & \textit{Action} \\\hline\\[2pt]
    \InitialState{}          &
      \begin{minipage}[t]{8cm}
        \begin{itemize}
          \item start connection thread (handshake, \mux{})
          \item transition to \UnnegotiatedStateIn{}.
          \item await for handshake result
          \item transition to \InboundIdleStateAny{}.
        \end{itemize}
      \end{minipage}
      \vspace{8pt}\\
    \ReservedOutboundState{} & the same as \InitialState{} \\[8pt]
    \UnnegotiatedStateAny{}  & \texttt{impossible state}\textsuperscript{$\dagger$} \\[8pt]
    \InboundIdleStateAny{}   & \texttt{impossible state}\textsuperscript{$\dagger$} \\[8pt]
    \InboundStateAny{}       & \texttt{impossible state}\textsuperscript{$\dagger$} \\[8pt]
    \OutboundStateAny{}      & \texttt{impossible state}\textsuperscript{$\dagger$} \\[8pt]
    \DuplexState{}           & \texttt{impossible state}\textsuperscript{$\dagger$} \\[8pt]
    \TerminatingState{}      & the same as \InitialState{} \\[8pt]
    \TerminatedState{}       & the same as \InitialState{} \\[8pt]
  \end{tabular}
  \caption{\texttt{includeInboundConnection}}
  \label{table:includeInboundConnection}
\end{table}
States indicated with a \textsuperscript{$\dagger$} are forbidden by \TCP{}.

\begin{table}
  \begin{tabular}[h]{llll}
    \textit{StateIn}         & \textit{StateOut} & \textit{Transition} \\\hline\\[2pt]
    \InitialState{}          & - & \\[8pt]
    \ReservedOutboundState{} & - & \\[8pt]
    \UnnegotiatedStateAny{}  & - & \\[8pt]
    \OutboundStateUni{}      & - & \\[8pt]
    \OutboundStateDup{}      & \Prune{} or (\DuplexState{} & \PromotedToWarmDupRem{}) \\[8pt]
    \InboundIdleStateUni{}   & \InboundStateUni{} & \AwakeUniRem{} \\[8pt]
    \InboundIdleStateDup{}   & \InboundStateDup{} & \AwakeDupRem{} \\[8pt]
    \InboundStateUni{}       & - & \\[8pt]
    \InboundStateDup{}       & - & \\[8pt]
    \DuplexState{}           & - & \\[8pt]
    \TerminatingState{}      & - & \\[8pt]
    \TerminatedState{}       & - & \\[8pt]
  \end{tabular}
  \caption{\texttt{promotedToWarmRemote}}
  \label{table:promotedToWarmRemote}
\end{table}

\begin{table}
  \begin{tabular}[h]{lll}
    \textit{StateIn}         & \textit{StateOut} & \textit{Transition} \\\hline\\[2pt]
    \ReservedOutboundState{} & - & - \\[8pt]
    \UnnegotiatedStateAny{}  & - & - \\[8pt]
    \OutboundStateAny{}      & - & - \\[8pt]
    \InboundIdleStateAny{}   & - & - \\[8pt]
    \InboundStateAny{}       & \InboundIdleStateAny{} & \DemotedToColdAnyRem{} \\[8pt]
    \DuplexState{}           & \OutboundStateDupTau{} & \DemotedToColdDupRem{} \\[8pt]
    \TerminatingState{}      & - & - \\[8pt]
    \TerminatedState{}       & - & - \\[8pt]
  \end{tabular}
  \caption{\texttt{demotedToColdRemote}}
  \label{table:demotedToColdRemote}
\end{table}

\begin{table}
  \begin{tabular}[h]{llll}
    \textit{StateIn}         & \textit{StateOut} & \textit{Returned Value} & \textit{Transition(s)}\\\hline\\[2pt]
    \InitialState{}          & - & - & \\[8pt]
    \ReservedOutboundState{} & - & - & \\[8pt]
    \UnnegotiatedStateAny{}  & - & - & \\[8pt]
    \OutboundStateUniTau{}   & $\dagger$ & - & \\[8pt]
    \OutboundStateUni{}      & $\dagger$ & - & \\[8pt]
    \OutboundStateDupTau{}   & \OutboundStateDup{} & - & \\[8pt]
    \OutboundStateDup{}      & $\dagger$ & - & \\[8pt]
    \InboundIdleStateAny{}   & \TerminatingState{} & \True & \\[8pt]
    \InboundStateAny{}       & \TerminatingState{}\textsuperscript{$\dagger$} & \True & \DemotedToColdAnyRem{} \\[8pt]
                             &                                                &       & \CommitAnyRem{} \\[8pt]
    \DuplexState{}           & \OutboundStateDup{} & \False & \DemotedToColdDupRem{} \\[8pt]
    \TerminatingState{}      & - & - & \\[8pt]
    \TerminatedState{}       & - & - & \\[8pt]
  \end{tabular}
  \caption{\texttt{unregisterInboundConnection}}
  \label{table:unregisterInboundConnection}
\end{table}

Transitions denoted by \textsuperscript{$\dagger$} should not happen.  The
implementation is using assertion, and the production system will trust that
the server side calls \texttt{unregisterInboundConnection} only after all
responder mini-protocols where idle for \textit{protocol idle timeout}.

\noindent\texttt{unregisterInboundConnection} might be called when the connection is in
\OutboundStateDup{}. This can, though very rarely, happen as a race between
\AwakeDupRem{} and \DemotedToColdDupRem{}\footnote{race is not the right term,
these transitions are concurrent and independent}. Let's consider the
following sequence of transitions:

\begin{center}
  \begin{tikzpicture}
    \node (init) at (0, 0) {\small\InitialState};
    \node[inbound_outbound_state] (UnnegotiatedStateIn)  at ( 0, -2) {\small\UnnegotiatedStateIn};
    \node[inbound_outbound_state] (InboundIdleStateDup) at ( 0, -4) {\small\InboundIdleStateDup};
    \node[inbound_outbound_state] (OutboundStateDup) at (0, -6) {\small\OutboundStateDup};

    \draw[->] (init) -- node [right] {\small\Accepted} (UnnegotiatedStateIn);
    \draw[->] (UnnegotiatedStateIn) -- node [right] {\small\NegotiatedDupIn} (InboundIdleStateDup);
    \draw[->] (InboundIdleStateDup) -- node [right] {\small\AwakeDupLoc} (OutboundStateDup);
  \end{tikzpicture}
\end{center}
If the \textit{protocol idle timeout} on the \InboundIdleStateDup{} expires
the \AwakeDupRem{} transition is triggered and the \inbgov{} calls
\texttt{unregisterInboundConnection}.

\begin{figure}[p]
  \begin{tikzpicture}[scale=0.66]
    \node                                     (init)                       at ( 2,   2)     {\small\InitialState};
    \node[outbound_state]                     (ReservedOutboundState)      at ( 0,-0.25)    {\small\ReservedOutboundState};
    \node[outbound_state,anchor=east]         (UnnegotiatedStateOut)       at (-1,  -3)     {\small\UnnegotiatedStateOut};
    \node[inbound_state]                      (UnnegotiatedStateIn)        at ( 5.5, -3)    {\small\UnnegotiatedStateIn};
    \node[inbound_outbound_state,anchor=west] (InboundIdleStateDup)        at ( 1, -6.0)    {\small\InboundIdleStateDup};
    \node[inbound_state,anchor=west]          (InboundIdleStateUni)        at ( 5, -8)      {\small\InboundIdleStateUni};
    \node[outbound_state,anchor=east]         (OutboundStateUni)           at (-2, -7.5)    {\small\OutboundStateUni};
    \node[inbound_outbound_state,anchor=east] (OutboundStateDupTau)        at (-1, -10.5)   {\small\OutboundStateDupTau};
    \node[inbound_outbound_state,anchor=east] (OutboundStateDup)           at (-1,  -14.0)  {\small\OutboundStateDupP};
    \node[inbound_state,anchor=west]          (InboundStateUni)            at ( 5, -16.0)   {\small\InboundStateUni};
    \node[inbound_outbound_state,anchor=west] (InboundStateDup)            at ( 1,  -13.5)  {\small\InboundStateDup};
    \node[inbound_outbound_state]             (DuplexState)                at (-1.5, -21.5) {\small\DuplexState};
    \node[inbound_outbound_state]             (OutboundIdleStateDup)       at ( 5,  -23)    {\small\OutboundIdleStateDup};
    \node[outbound_state]                     (OutboundIdleStateUni)       at (-5,  -24.5)  {\small\OutboundIdleStateUni};
    \node[inbound_outbound_state]             (TerminatingState)           at ( 3,  -27)    {\small\TerminatingState};
    \node[inbound_outbound_state]             (TerminatedState)            at ( 3,  -30)    {\small\TerminatedState};


    % legend
    \node[anchor=west]                         at (8,-25.25) {\textbf{Legend:}};
    \node[requestOutboundArr,anchor=west]      at (8,-26)    {\texttt{requestOutboundConnection}};
    \node[unregisterOutboundArr,anchor=west]   at (8,-26.75) {\texttt{unregisterOutboundConnection}};
    \node[registerInboundArr,anchor=west]       at (8,-27.5)  {\texttt{includeInboundConnection}};
    \node[promotedToWarmRemoteArr,anchor=west] at (8,-28.25) {\texttt{promotedToWarmRemote}};
    \node[demotedToColdRemoteArr,anchor=west]  at (8,-29)    {\texttt{demotedToColdRemote}};
    \node[unregisterInboundArr,anchor=west]    at (8,-29.75) {\texttt{unregisterInboundConnection}};

    \draw[->,requestOutboundArr] (init) -- node[fill=white,pos=0.425,above left]{\small\Reserve}                                          (ReservedOutboundState);
    \draw[->,registerInboundArr] (init) to [out=310, in=90] node[fill=white, above right]{\small\Accepted}                                (UnnegotiatedStateIn.30);

    \draw[->,requestOutboundArr] (ReservedOutboundState)          -- node[fill=white,above left] {\small\Connected}                       (UnnegotiatedStateOut);
    \draw[->,registerInboundArr] (ReservedOutboundState)          -- node[fill=white,above right] {\small\Overwritten}                    (UnnegotiatedStateIn);

    \draw[->,requestOutboundArr] (UnnegotiatedStateOut)           -- node[fill=white,left=-42pt] {\small\NegotiatedUniOut}                (OutboundStateUni.165);
    \draw[->,requestOutboundArr] (UnnegotiatedStateOut.340)       to [out=-60, in=90]
                                               node[fill=white,right=-30pt,pos=0.23]{\small\NegotiatedDupOut}          (OutboundStateDupTau.13);

    \draw[->, registerInboundArr]         (UnnegotiatedStateIn)    -- node[fill=white,left=-12pt]{\small\NegotiatedDupIn}                  (InboundIdleStateDup.150);
    \draw[->, registerInboundArr]         (UnnegotiatedStateIn)    -- node[fill=white,pos=0.35,right=-28pt]{\small\NegotiatedUniIn}        (InboundIdleStateUni.60);

    \draw[->, unregisterInboundArr]         (InboundIdleStateUni.320) to [out=-90,in=40]
                                                node[fill=white,pos=0.5,rotate=70,left=-15pt]{\small\CommitUniRem}     (TerminatingState.0);
    \draw[->, dashed,  demotedToColdRemoteArr] (InboundStateUni.10)      -- node[pos=0.3,fill=white,right=-45pt]{\small\DemotedToColdUniRem}    (InboundIdleStateUni.350);
    \draw[->, requestOutboundArr]         (InboundIdleStateDup.195) -- node[fill=white,pos=0.4]{\small\AwakeDupLoc}                        (OutboundStateDupTau.10);

    \draw[->, dashed, promotedToWarmRemoteArr] (InboundIdleStateDup.200) -- node[fill=white,pos=0.65]{\small\AwakeDupRem}                       (InboundStateDup.160);
    \draw[->, unregisterOutboundArr]         (OutboundStateDupTau.150) to [out=90,in=-170]
                                                node[fill=white,pos=0.10,left=-56pt]{\small\DemotedToColdDupLoc}       (InboundIdleStateDup.180);
    \draw[->, unregisterOutboundArr]         (OutboundStateDup.192)    to [out=-90,in=180,looseness=2]
                                                node[fill=white,rotate=90,pos=0.2]{\small\DemotedToColdDupLoc}         (OutboundIdleStateDup.180);
    \draw[->, unregisterInboundArr]         (OutboundStateDupTau.192) --
                                                node[fill=white] {\small\TimeoutExpired}
                                                (OutboundStateDup.168);
    \draw[->, requestOutboundArr]         (InboundStateDup)         to [out=-110,in=40]
                                                node[pos=0.9,right=20pt,rotate=70]{\footnotesize\PromotedToWarmDupLoc}     (DuplexState.10);
    \draw[->, dashed, promotedToWarmRemoteArr] (OutboundIdleStateDup.60) to [out=90, in=270]
                                                node[fill=white,rotate=90,pos=0.6,below=30pt]{\footnotesize\AwakeDupRem}   (InboundStateDup.345);
    \draw[->, unregisterOutboundArr]         (DuplexState)             to [out=50,in=220]
                                                node[fill=white,pos=0.90,left=24pt,rotate=65]{\small\DemotedToColdDupLoc}  (InboundStateDup);
    \draw[->, dashed, demotedToColdRemoteArr] (DuplexState.155)         to [out=90,in=-40]
                                                node[fill=white,right=10pt,pos=0.01,rotate=80]{\small\DemotedToColdDupRem} (OutboundStateDupTau);

    \draw[dashed, promotedToWarmRemoteArr] (OutboundStateDupTau)         -- (OutboundStateDup.south);
    \filldraw (OutboundStateDupTau.south) circle [radius=3pt];
    \filldraw (OutboundStateDup.south)    circle [radius=3pt];
    \draw[->, dashed, promotedToWarmRemoteArr] (OutboundStateDup)        to [out=-90,in=180]
                                                node[left,pos=0.05,left=10pt,rotate=80]{\small\PromotedToWarmDupRem}  (DuplexState);

    \draw[->, unregisterInboundArr]         (InboundIdleStateDup.270) to [out=-80,in=80]
                                                      node[fill=white,pos=0.5,left=-10pt,rotate=80]{\small\CommitDupRem} (TerminatingState.155);
    \draw[->, dashed, promotedToWarmRemoteArr] (InboundIdleStateUni.200) -- node[fill=white,right=-15pt]{\small\AwakeUniRem}                   (InboundStateUni.160);
    \draw[->, dashed, demotedToColdRemoteArr] (InboundStateDup.15)      -- node[fill=white,left=-75pt,pos=0.5]{\small\DemotedToColdDupRem}    (InboundIdleStateDup.345);
    \draw[->, unregisterOutboundArr]         (OutboundStateUni.190)    to [out=270, in=90,pos=0.23,looseness=2]
                                                node[fill=white,rotate=88,pos=0.3]{\small\DemotedToColdUniLoc}        (OutboundIdleStateUni.173);

    \draw[->, unregisterOutboundArr]         (OutboundIdleStateUni)       to [out=300, in=180] node[fill=white,below left]{\CommitUniLoc}         (TerminatingState.180);
    \draw[->, unregisterOutboundArr]         (OutboundIdleStateDup.280)   -- node[fill=white,pos=.4]{\CommitDupLoc}                          (TerminatingState.40);
    \draw[->]         (TerminatingState)           -- node[left]{\Terminate}                                          (TerminatedState);

    \draw[->, registerInboundArr]            (UnnegotiatedStateOut)    -- node[above]{\small\SelfConn}                                       (UnnegotiatedStateIn);

  \end{tikzpicture}
  \caption{Transitions classified by connection manager method.}
  \label{fig:methods}
\end{figure}

\section{Server}

The server consists of an accept loop and an \inbgov{}.  The
accept loop is using \texttt{includeInboundConnnection} on incoming
connections, while the \inbgov{} tracks the state of the responder side of all
mini-protocols and it is responsible for starting and restarting
mini-protocols, as well as detecting if they are used to support:

\begin{itemize}
  \item \PromotedToWarmDupRem{},
  \item \DemotedToColdUniRem{},
  \item \CommitUniRem{} and \CommitDupRem{} transitions.
\end{itemize}

The \inbgov{} will always start/restart all the mini-protocols using
\texttt{StartOnDemand} strategy.  When the multiplexer detects
any traffic on its ingress queues, corresponding to responder protocols,
it will do the \PromotedToWarmDupRem{} transition using
\texttt{promotedToWarmRemote} method.

Once all responder mini-protocols become idle, i.e. they all stopped, were
restarted (on-demand) but are not yet running, a \DemotedToColdAnyRem{}
transition is run: the \inbgov{} will notify the \connmngr{} using:

\begin{lstlisting}
-- | Notify the 'ConnectionManager' that a remote end demoted us to a /cold
-- peer/.
--
-- This executes:
--
-- * \(DemotedToCold^{*}_{Remote}\) transition.
demotedToColdRemote
    :: HasResponder muxMode ~ True
    => ConnectionManager muxMode socket peerAddr handle handleError m
    -> peerAddr -> m (OperationResult InState)
\end{lstlisting}

When all responder mini-protocols are idle for \textit{protocol idle timeout},
the \inbgov{} will execute \texttt{unregisterInboundConnection} which will trigger:
\begin{itemize}
  \item \CommitUniRem{} or \CommitDupRem{} if the initial state is
    \InboundIdleStateDup{};
  \item \TimeoutExpired{}  if the initial state is \OutboundStateDupTau{};
  \item \texttt{no-op}  if the initial state is \OutboundStateDup{} or \OutboundIdleStateAny{}.
\end{itemize}

\begin{lstlisting}
-- | Return the value of 'unregisterInboundConnection' to inform the caller about
-- the transition.
--
data DemotedToColdRemoteTr =
    -- | @Commit^{dataFlow}@ transition from @'InboundIdleState' dataFlow@.
    --
    CommitTr

    -- | @DemotedToCold^{Remote}@ transition from @'InboundState' dataFlow@
    --
  | DemotedToColdRemoteTr

    -- | Either @DemotedToCold^{Remote}@ transition from @'DuplexState'@, or
    -- a level triggered @Awake^{Duplex}_{Local}@ transition.  In both cases
    -- the server must keep the responder's side of all protocols ready.
  | KeepTr
  deriving Show

unregisterInboundConnection *'$\coloncolon$'* peerAddr *'$\Rightarrow$'* m (OperationResult DemotedToColdRemoteTr)
\end{lstlisting}
Both \CommitUniRem{} and \CommitDupRem{} will free resources (terminate the
connection thread, close the socket).


\section{Inbound Protocol Governor}
\textit{Inbound protocol governor} keeps track of the responder side of the protocol for
both inbound and outbound duplex connections.  Unidirectional outbound
connections are not tracked by \inbgov{}.  The server and connection manager
are responsible for notifying it about new connections once negotiated.
Figure~\ref{fig:inbgov-state-machine} presents the state machine that drives
changes to connection states tracked by \inbgov{}.  As in the connection
manager case, there is an implicit transition from every state to the
terminating state, representing mux or mini-protocol failures.

\begin{figure}[h!]
  \begin{center}
    \begin{tikzpicture}
      \node (InitialState)              at (0, 0)   {\InitialState};
      \node[inbound_state] (RemoteCold) at (0, -4)  {\RemoteCold};
      \node[inbound_state] (RemoteIdle) at (0, -8)  {\RemoteIdle};
      \node[inbound_state] (RemoteWarm) at (0, -12) {\RemoteWarm};
      \node[inbound_state] (RemoteHot)  at (0, -16) {\RemoteHot};

      \draw[->] (RemoteWarm.180)   to [out=120,in=240]                                (InitialState);
      \draw[->] (RemoteHot.180)    to [out=120,in=240]                                (InitialState);
      \draw[->] (RemoteIdle.180)   to [out=110,in=240]                                (InitialState);
      \draw[->] (RemoteCold.180)   to [out=100,in=240] node[fill=white,left=-30pt,pos=0.55]
                                                           {\MuxTerminated}           (InitialState);

      \draw[->] (InitialState)     to [out=350,in=20]  node[fill=white,pos=0.55]
                                                           {\NewConnection}           (RemoteIdle.0);

      \draw[->] (RemoteWarm.140)   to [out=120,in=240] node[fill=white,left=-50pt,pos=0.4]
                                                           {\WaitIdleRemote}          (RemoteIdle.220);

      \draw[->] (RemoteIdle)       to [out=55,in=305]                                 (InitialState);
      \draw[->] (RemoteIdle)       to [out=70,in=290]  node[fill=white,left=-40pt,pos=0.3]
                                                           {\CommitRemote}            (RemoteCold);

      \draw[->] (RemoteCold.340)   to [out=300,in=60]                                 (RemoteWarm.30);
      \draw[->] (RemoteIdle.320)   to [out=330,in=60]  node[fill=white,left=-45pt]
                                                            {\AwakeRemote}            (RemoteWarm.30);

      \draw[->] (RemoteWarm)       edge[loop right]    node[right]
                                                           {\MiniProtocolTerminated}  (RemoteWarm);
      \draw[->] (RemoteHot)        edge[loop right]    node[right]
                                                           {\MiniProtocolTerminated}  (RemoteHot);

      \draw[->] (RemoteHot.70)     to [out=60,in=300]   node[fill=white,right=-25pt,pos=0.4]
                                                            {\DemotedToWarmRemote}    (RemoteWarm.290);
      \draw[->] (RemoteWarm.250)   to [out=240,in=120]  node[fill=white,left=-80pt,pos=0.4]
                                                            {\PromotedToHotRemote}    (RemoteHot.110);
    \end{tikzpicture}
    \caption{Inbound protocol governor state machine}
    \label{fig:inbgov-state-machine}
  \end{center}
\end{figure}

\subsection{States}

States of the inbound governor are similar to the outbound governor, but there
are crucial differences.

\subsubsection{\RemoteCold}
The remote cold state signifies that the remote peer is not using the
connection, however the only reason why the inbound governor needs to track
that connection is because the outbound side of this connection is used.  The
inbound governor will wait until any of the responder mini-protocols wakes up
(\AwakeRemote{}) or the mux will be shut down (\MuxTerminated{}).

\subsubsection{\RemoteIdle}
The \RemoteIdle{} state is the initial state of each new connection
(\NewConnection{}).  An active connection will become \RemoteIdle{} once the
inbound governor detects that all responder mini-protocols terminated
(\WaitIdleRemote{}).  When a connection enters this state, an idle timeout is
started.  If no activity is detected on the responders, the connection will
either be closed by the connection manager and forgotten by the inbound
governor or progress to the \RemoteCold{} state.  This depends on whether the
connection is used (\warm{} or \hot{}) or not (\cold{}) by the outbound side.

\subsubsection{\RemoteWarm}
A connection dwells in \RemoteWarm{} if there are strictly only any warm or established
responder protocols running. Note also that an established protocol is one that may run
in both hot and warm states, but cannot be the only type running to maintain hot state
once all proper hot protocols have terminated. In other words, the connection must be
demoted in that case.

\subsubsection{\RemoteHot}
A connection enters \RemoteHot{} state once any hot responder protocol has started.
In particular, if a hot responder is the first to start, the state cycles through \RemoteWarm{}
first. Once all hot responders terminate, the connection will be put in \RemoteWarm{} regardless
of whether there are any warm or established responders left. In the latter case, if there aren't any
other protocols running, the connection will then follow up with further demotion to \RemoteIdle{}.

\subsection{Transitions}

\subsubsection{\NewConnection}
Inbound and outbound duplex connections are passed to the inbound governor.
They are then put in \RemoteIdle{} state.

\subsubsection{\CommitRemote}
Once the \RemoteIdle{} timeout expires, the inbound governor will call
\texttt{unregisterInboundConnection}.  The
connection will either be forgotten or kept in \RemoteCold{} state depending on the returned value.

\subsubsection{\AwakeRemote}
While a connection was put in \RemoteIdle{} state, it is possible that the
remote end will start using it.  When the inbound governor detects that any
of the responders is active, it will put that connection in \RemoteWarm{} state.

\begin{detail}
  The inbound governor calls \texttt{promotedToWarmRemote} to notify the
  connection manager about the state change.
\end{detail}

\subsubsection{\WaitIdleRemote}
\WaitIdleRemote{} transition happens once all mini-protocol is terminated.

\begin{detail}
  The inbound governor calls \texttt{demotedToColdRemote}.   If it returns
  \texttt{TerminatedConnection} the connection will be forgotten (as in
  \MuxTerminated{} transition), if it returns \texttt{OperationSuccess} it will
  register a idle timeout.
\end{detail}

\subsubsection{\MiniProtocolTerminated}
When any of the mini-protocols terminates, the inbound governor will restart the
responder and update the internal state of the connection (e.g. update the stm
transaction, which tracks the state of the mini-protocol).

\begin{detail}
  The implementation distinguishes two situations: whether the mini-protocol
  terminated or errored.  The multiplexer guarantees that if it errors, the
  multiplexer will be closed (and thus, the connection thread will exit, and the
  associated socket will be closed).   Hence, the inbound governor can forget about the
  connection
  (perform \MuxTerminated{}).

  The inbound governor does not notify the connection manager about a terminating
  responder mini-protocol.
\end{detail}

\subsubsection{\MuxTerminated}
The inbound governor monitors the multiplexer.  As soon as it exists, the
connection will be forgotten.

The inbound governor does not notify the connection manager about the
termination of the connection, as it can detect this by itself.

\subsubsection{\PromotedToHotRemote}
The inbound governor detects when any \hot{} mini-protocols have started.   In such
case a \RemoteWarm{} connection is put in \RemoteHot{} state.

\subsubsection{\DemotedToWarmRemote}
Dually to \PromotedToHotRemote{} state transition, as soon as all of the \hot{}
mini-protocols terminate, the connection will transition to \RemoteWarm{}
state.
